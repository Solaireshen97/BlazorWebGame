# 任务：创建支持组队战斗的 BlazorIdleGame 客户端

## 项目需求
创建一个支持组队战斗的放置类游戏前端，需要实现：
1. 单人和组队两种游戏模式
2. 实时显示队友战斗状态
3. 组队管理（创建/加入/离开队伍）
4. 战斗同步显示
5. 资源和奖励分配

## 步骤 1：创建项目和安装依赖

```bash
# 创建项目
创建新的客户端项目 BlazorIdleGame.Rebuild

# 添加必要的NuGet包
dotnet add package Fluxor.Blazor.Web --version 5.9.1
dotnet add package Fluxor.Blazor.Web.ReduxDevTools --version 5.9.1
dotnet add package Microsoft.AspNetCore.SignalR.Client --version 8.0.0
```

## 步骤 2：创建项目结构

```
BlazorIdleGame.Client/
├── Models/
│   ├── GameModels.cs         # 基础游戏模型
│   ├── PartyModels.cs        # 组队相关模型
│   └── BattleModels.cs       # 战斗相关模型
├── Services/
│   ├── IGameService.cs       # 游戏服务接口
│   ├── GameService.cs        # 游戏服务实现
│   ├── PartyService.cs       # 组队服务
│   └── BattleService.cs      # 战斗服务
├── Store/
│   ├── GameStore/           # 游戏状态
│   ├── PartyStore/          # 组队状态
│   └── BattleStore/         # 战斗状态
├── Components/
│   ├── Game/               # 游戏组件
│   ├── Party/              # 组队组件
│   └── Battle/             # 战斗组件
├── Pages/
│   ├── Game.razor          # 游戏主页
│   ├── Party.razor         # 组队页面
│   └── Battle.razor        # 战斗页面
└── wwwroot/
    ├── css/
    │   └── app.css
    └── js/
        └── game.js
```

## 步骤 3：创建所有文件

### 文件 1：Models/GameModels.cs
```csharp
using System;
using System.Collections.Generic;

namespace BlazorIdleGame.Client.Models
{
    // ========== 基础游戏模型 ==========
    public class GameState
    {
        public PlayerInfo Player { get; set; } = new();
        public Resources Resources { get; set; } = new();
        public List<Activity> Activities { get; set; } = new();
        public PartyInfo? CurrentParty { get; set; }
        public BattleState? CurrentBattle { get; set; }
        public DateTime ServerTime { get; set; }
        public int Version { get; set; }
        public DateTime LastSyncTime { get; set; }
    }
    
    public class PlayerInfo
    {
        public string Id { get; set; } = "";
        public string Name { get; set; } = "";
        public int Level { get; set; } = 1;
        public long Experience { get; set; }
        public long ExperienceToNext { get; set; } = 100;
        public CharacterStats Stats { get; set; } = new();
        public bool InParty => !string.IsNullOrEmpty(PartyId);
        public string? PartyId { get; set; }
        
        public double ExperiencePercent => ExperienceToNext > 0 
            ? (double)Experience / ExperienceToNext * 100 
            : 0;
    }
    
    public class CharacterStats
    {
        public int Health { get; set; } = 100;
        public int MaxHealth { get; set; } = 100;
        public int AttackPower { get; set; } = 10;
        public int Defense { get; set; } = 5;
        public double AttackSpeed { get; set; } = 1.0;
    }
    
    public class Resources
    {
        public long Gold { get; set; }
        public long Wood { get; set; }
        public long Stone { get; set; }
        public long Iron { get; set; }
        public Dictionary<string, long> Others { get; set; } = new();
    }
    
    public class Activity
    {
        public string Id { get; set; } = "";
        public string Name { get; set; } = "";
        public ActivityType Type { get; set; }
        public DateTime StartTime { get; set; }
        public DateTime EndTime { get; set; }
        public int CurrentLoop { get; set; }
        public int MaxLoops { get; set; }
        public Dictionary<string, long> RewardsPerLoop { get; set; } = new();
        public bool IsPartyActivity { get; set; }
        
        public double Progress
        {
            get
            {
                var now = DateTime.UtcNow;
                if (now >= EndTime) return 1.0;
                if (now <= StartTime) return 0.0;
                
                var total = (EndTime - StartTime).TotalSeconds;
                var elapsed = (now - StartTime).TotalSeconds;
                return Math.Min(elapsed / total, 1.0);
            }
        }
        
        public TimeSpan TimeRemaining => EndTime > DateTime.UtcNow 
            ? EndTime - DateTime.UtcNow 
            : TimeSpan.Zero;
    }
    
    public enum ActivityType
    {
        Battle,
        Gathering,
        Crafting,
        Training,
        PartyBattle,    // 组队战斗
        PartyRaid       // 团队副本
    }
    
    public class ApiResponse<T>
    {
        public bool Success { get; set; }
        public T? Data { get; set; }
        public string? Message { get; set; }
        public List<string> Errors { get; set; } = new();
    }
    
    public class GameAction
    {
        public string ActionType { get; set; } = "";
        public Dictionary<string, object> Parameters { get; set; } = new();
        public DateTime ClientTime { get; set; } = DateTime.UtcNow;
    }
}
```

### 文件 2：Models/PartyModels.cs
```csharp
using System;
using System.Collections.Generic;

namespace BlazorIdleGame.Client.Models
{
    public class PartyInfo
    {
        public string Id { get; set; } = "";
        public string Name { get; set; } = "";
        public string LeaderId { get; set; } = "";
        public List<PartyMember> Members { get; set; } = new();
        public int MaxMembers { get; set; } = 5;
        public PartyStatus Status { get; set; }
        public string? CurrentActivityId { get; set; }
        public DateTime CreatedAt { get; set; }
        
        public bool IsFull => Members.Count >= MaxMembers;
        public bool IsInActivity => !string.IsNullOrEmpty(CurrentActivityId);
    }
    
    public class PartyMember
    {
        public string Id { get; set; } = "";
        public string Name { get; set; } = "";
        public int Level { get; set; }
        public CharacterStats Stats { get; set; } = new();
        public bool IsLeader { get; set; }
        public bool IsReady { get; set; }
        public MemberStatus Status { get; set; }
        public DateTime JoinedAt { get; set; }
    }
    
    public enum PartyStatus
    {
        Idle,           // 空闲
        Preparing,      // 准备中
        InActivity,     // 活动中
        Disbanding      // 解散中
    }
    
    public enum MemberStatus
    {
        Online,         // 在线
        InBattle,       // 战斗中
        Idle,          // 空闲
        Offline        // 离线
    }
    
    public class PartyInvite
    {
        public string InviteId { get; set; } = "";
        public string PartyId { get; set; } = "";
        public string PartyName { get; set; } = "";
        public string InviterName { get; set; } = "";
        public DateTime ExpireTime { get; set; }
    }
    
    public class PartyRequest
    {
        public string RequestId { get; set; } = "";
        public string PlayerId { get; set; } = "";
        public string PlayerName { get; set; } = "";
        public int PlayerLevel { get; set; }
        public DateTime RequestTime { get; set; }
    }
}
```

### 文件 3：Models/BattleModels.cs
```csharp
using System;
using System.Collections.Generic;

namespace BlazorIdleGame.Client.Models
{
    public class BattleState
    {
        public string BattleId { get; set; } = "";
        public BattleType Type { get; set; }
        public List<BattleParticipant> PlayerTeam { get; set; } = new();
        public List<BattleParticipant> EnemyTeam { get; set; } = new();
        public int Round { get; set; }
        public BattleStatus Status { get; set; }
        public DateTime StartTime { get; set; }
        public DateTime? EndTime { get; set; }
        public List<BattleLog> Logs { get; set; } = new();
        public BattleRewards? Rewards { get; set; }
        
        public bool IsPartyBattle => PlayerTeam.Count > 1;
        public bool IsActive => Status == BattleStatus.InProgress;
    }
    
    public class BattleParticipant
    {
        public string Id { get; set; } = "";
        public string Name { get; set; } = "";
        public int Level { get; set; }
        public int CurrentHealth { get; set; }
        public int MaxHealth { get; set; }
        public int AttackPower { get; set; }
        public int Defense { get; set; }
        public double AttackSpeed { get; set; }
        public bool IsPlayer { get; set; }
        public bool IsAlive => CurrentHealth > 0;
        public double NextAttackTime { get; set; }
        
        public double HealthPercent => MaxHealth > 0 
            ? (double)CurrentHealth / MaxHealth * 100 
            : 0;
    }
    
    public enum BattleType
    {
        Solo,           // 单人战斗
        Party,          // 组队战斗
        Raid,           // 团队副本
        PvP            // PvP对战
    }
    
    public enum BattleStatus
    {
        Preparing,      // 准备中
        InProgress,     // 进行中
        Victory,        // 胜利
        Defeat,         // 失败
        Abandoned       // 放弃
    }
    
    public class BattleLog
    {
        public DateTime Timestamp { get; set; }
        public string AttackerId { get; set; } = "";
        public string AttackerName { get; set; } = "";
        public string TargetId { get; set; } = "";
        public string TargetName { get; set; } = "";
        public int Damage { get; set; }
        public BattleActionType ActionType { get; set; }
        public bool IsCritical { get; set; }
    }
    
    public enum BattleActionType
    {
        Attack,         // 普通攻击
        Skill,          // 技能
        Heal,           // 治疗
        Buff,           // 增益
        Debuff         // 减益
    }
    
    public class BattleRewards
    {
        public long Experience { get; set; }
        public long Gold { get; set; }
        public Dictionary<string, int> Items { get; set; } = new();
        public bool IsPartyReward { get; set; }
        public Dictionary<string, long>? MemberRewards { get; set; }
    }
}
```

### 文件 4：Services/GameService.cs
```csharp
using System;
using System.Net.Http;
using System.Net.Http.Json;
using System.Threading;
using System.Threading.Tasks;
using BlazorIdleGame.Client.Models;
using Microsoft.AspNetCore.SignalR.Client;
using Microsoft.Extensions.Logging;

namespace BlazorIdleGame.Client.Services
{
    public interface IGameService
    {
        GameState? CurrentState { get; }
        bool IsConnected { get; }
        bool IsLoading { get; }
        
        event EventHandler<GameState>? StateUpdated;
        event EventHandler<bool>? ConnectionChanged;
        event EventHandler<string>? ErrorOccurred;
        
        Task InitializeAsync();
        Task<bool> StartActivityAsync(ActivityType type, string target);
        Task<bool> StopActivityAsync(string activityId);
        Task<bool> SendActionAsync(GameAction action);
        void Dispose();
    }
    
    public class GameService : IGameService, IDisposable
    {
        private readonly HttpClient _http;
        private readonly ILogger<GameService> _logger;
        private readonly IPartyService _partyService;
        private readonly IBattleService _battleService;
        
        private Timer? _syncTimer;
        private GameState? _state;
        private bool _isConnected;
        private bool _isLoading;
        private readonly SemaphoreSlim _lock = new(1, 1);
        
        // 动态同步间隔
        private int _syncInterval = 5000;
        
        public GameState? CurrentState => _state;
        public bool IsConnected => _isConnected;
        public bool IsLoading => _isLoading;
        
        public event EventHandler<GameState>? StateUpdated;
        public event EventHandler<bool>? ConnectionChanged;
        public event EventHandler<string>? ErrorOccurred;
        
        public GameService(
            HttpClient http, 
            ILogger<GameService> logger,
            IPartyService partyService,
            IBattleService battleService)
        {
            _http = http;
            _logger = logger;
            _partyService = partyService;
            _battleService = battleService;
        }
        
        public async Task InitializeAsync()
        {
            _logger.LogInformation("初始化游戏服务");
            _isLoading = true;
            
            try
            {
                // 初始化子服务
                await _partyService.InitializeAsync();
                await _battleService.InitializeAsync();
                
                // 订阅子服务事件
                _partyService.PartyUpdated += OnPartyUpdated;
                _battleService.BattleUpdated += OnBattleUpdated;
                
                // 首次同步
                await SyncStateAsync();
                
                // 启动定时同步
                StartPolling();
                
                _isLoading = false;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "初始化失败");
                _isLoading = false;
                ErrorOccurred?.Invoke(this, "初始化失败，请刷新页面重试");
            }
        }
        
        private void StartPolling()
        {
            _syncTimer?.Dispose();
            _syncTimer = new Timer(
                async _ => await SyncStateAsync(),
                null,
                TimeSpan.FromMilliseconds(_syncInterval),
                TimeSpan.FromMilliseconds(_syncInterval)
            );
        }
        
        private async Task SyncStateAsync()
        {
            if (!await _lock.WaitAsync(0))
                return;
                
            try
            {
                var response = await _http.GetFromJsonAsync<ApiResponse<GameState>>(
                    $"api/game/state?v={_state?.Version ?? 0}");
                
                if (response?.Success == true && response.Data != null)
                {
                    var newState = response.Data;
                    
                    // 根据状态调整同步频率
                    AdjustSyncInterval(newState);
                    
                    if (_state == null || _state.Version != newState.Version)
                    {
                        _state = newState;
                        StateUpdated?.Invoke(this, newState);
                        
                        // 更新子服务状态
                        if (newState.CurrentParty != null)
                            _partyService.UpdatePartyState(newState.CurrentParty);
                        if (newState.CurrentBattle != null)
                            _battleService.UpdateBattleState(newState.CurrentBattle);
                    }
                    
                    if (!_isConnected)
                    {
                        _isConnected = true;
                        ConnectionChanged?.Invoke(this, true);
                    }
                }
            }
            catch (HttpRequestException ex)
            {
                _logger.LogError(ex, "网络请求失败");
                HandleConnectionError();
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "同步状态失败");
            }
            finally
            {
                _lock.Release();
            }
        }
        
        private void AdjustSyncInterval(GameState state)
        {
            var newInterval = _syncInterval;
            
            if (state.CurrentBattle?.IsActive == true)
            {
                // 战斗中加快同步
                newInterval = state.CurrentBattle.IsPartyBattle ? 1000 : 2000;
            }
            else if (state.CurrentParty?.IsInActivity == true)
            {
                // 组队活动中
                newInterval = 2000;
            }
            else if (state.Activities.Any(a => a.TimeRemaining.TotalSeconds < 10))
            {
                // 活动即将结束
                newInterval = 1000;
            }
            else
            {
                // 正常状态
                newInterval = 5000;
            }
            
            if (newInterval != _syncInterval)
            {
                _syncInterval = newInterval;
                StartPolling(); // 重启定时器
            }
        }
        
        public async Task<bool> StartActivityAsync(ActivityType type, string target)
        {
            var action = new GameAction
            {
                ActionType = "StartActivity",
                Parameters = new()
                {
                    ["type"] = type.ToString(),
                    ["target"] = target,
                    ["isPartyActivity"] = type == ActivityType.PartyBattle || type == ActivityType.PartyRaid
                }
            };
            
            return await SendActionAsync(action);
        }
        
        public async Task<bool> StopActivityAsync(string activityId)
        {
            var action = new GameAction
            {
                ActionType = "StopActivity",
                Parameters = new()
                {
                    ["activityId"] = activityId
                }
            };
            
            return await SendActionAsync(action);
        }
        
        public async Task<bool> SendActionAsync(GameAction action)
        {
            try
            {
                var response = await _http.PostAsJsonAsync("api/game/action", action);
                
                if (response.IsSuccessStatusCode)
                {
                    // 立即同步新状态
                    await SyncStateAsync();
                    return true;
                }
                
                var error = await response.Content.ReadAsStringAsync();
                ErrorOccurred?.Invoke(this, $"操作失败: {error}");
                return false;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "发送操作失败");
                ErrorOccurred?.Invoke(this, "操作失败，请重试");
                return false;
            }
        }
        
        private void OnPartyUpdated(object? sender, PartyInfo party)
        {
            if (_state != null)
            {
                _state.CurrentParty = party;
                StateUpdated?.Invoke(this, _state);
            }
        }
        
        private void OnBattleUpdated(object? sender, BattleState battle)
        {
            if (_state != null)
            {
                _state.CurrentBattle = battle;
                StateUpdated?.Invoke(this, _state);
            }
        }
        
        private void HandleConnectionError()
        {
            if (_isConnected)
            {
                _isConnected = false;
                ConnectionChanged?.Invoke(this, false);
                ErrorOccurred?.Invoke(this, "连接已断开，正在重连...");
            }
        }
        
        public void Dispose()
        {
            _syncTimer?.Dispose();
            _lock?.Dispose();
            _partyService.PartyUpdated -= OnPartyUpdated;
            _battleService.BattleUpdated -= OnBattleUpdated;
            _partyService.Dispose();
            _battleService.Dispose();
        }
    }
}
```

### 文件 5：Services/PartyService.cs
```csharp
using System;
using System.Net.Http;
using System.Net.Http.Json;
using System.Threading.Tasks;
using System.Collections.Generic;
using BlazorIdleGame.Client.Models;
using Microsoft.AspNetCore.SignalR.Client;
using Microsoft.Extensions.Logging;

namespace BlazorIdleGame.Client.Services
{
    public interface IPartyService
    {
        PartyInfo? CurrentParty { get; }
        List<PartyInfo> AvailableParties { get; }
        List<PartyInvite> PendingInvites { get; }
        
        event EventHandler<PartyInfo>? PartyUpdated;
        event EventHandler<PartyInvite>? InviteReceived;
        event EventHandler<string>? MemberJoined;
        event EventHandler<string>? MemberLeft;
        
        Task InitializeAsync();
        Task<bool> CreatePartyAsync(string name, int maxMembers = 5);
        Task<bool> JoinPartyAsync(string partyId);
        Task<bool> LeavePartyAsync();
        Task<bool> InvitePlayerAsync(string playerId);
        Task<bool> KickMemberAsync(string memberId);
        Task<bool> PromoteToLeaderAsync(string memberId);
        Task<bool> SetReadyStatusAsync(bool isReady);
        Task<List<PartyInfo>> GetAvailablePartiesAsync();
        void UpdatePartyState(PartyInfo party);
        void Dispose();
    }
    
    public class PartyService : IPartyService, IDisposable
    {
        private readonly HttpClient _http;
        private readonly ILogger<PartyService> _logger;
        private HubConnection? _hubConnection;
        
        private PartyInfo? _currentParty;
        private List<PartyInfo> _availableParties = new();
        private List<PartyInvite> _pendingInvites = new();
        
        public PartyInfo? CurrentParty => _currentParty;
        public List<PartyInfo> AvailableParties => _availableParties;
        public List<PartyInvite> PendingInvites => _pendingInvites;
        
        public event EventHandler<PartyInfo>? PartyUpdated;
        public event EventHandler<PartyInvite>? InviteReceived;
        public event EventHandler<string>? MemberJoined;
        public event EventHandler<string>? MemberLeft;
        
        public PartyService(HttpClient http, ILogger<PartyService> logger)
        {
            _http = http;
            _logger = logger;
        }
        
        public async Task InitializeAsync()
        {
            try
            {
                // 尝试建立SignalR连接（用于实时组队通知）
                _hubConnection = new HubConnectionBuilder()
                    .WithUrl($"{_http.BaseAddress}partyHub")
                    .WithAutomaticReconnect()
                    .Build();
                
                // 注册SignalR事件处理
                _hubConnection.On<PartyInfo>("PartyUpdated", party =>
                {
                    _currentParty = party;
                    PartyUpdated?.Invoke(this, party);
                });
                
                _hubConnection.On<PartyInvite>("InviteReceived", invite =>
                {
                    _pendingInvites.Add(invite);
                    InviteReceived?.Invoke(this, invite);
                });
                
                _hubConnection.On<string, string>("MemberJoined", (partyId, memberName) =>
                {
                    if (_currentParty?.Id == partyId)
                    {
                        MemberJoined?.Invoke(this, memberName);
                    }
                });
                
                _hubConnection.On<string, string>("MemberLeft", (partyId, memberName) =>
                {
                    if (_currentParty?.Id == partyId)
                    {
                        MemberLeft?.Invoke(this, memberName);
                    }
                });
                
                await _hubConnection.StartAsync();
                _logger.LogInformation("SignalR连接成功");
            }
            catch (Exception ex)
            {
                _logger.LogWarning(ex, "SignalR连接失败，使用HTTP轮询模式");
                // SignalR失败不影响游戏，降级到纯HTTP模式
            }
        }
        
        public async Task<bool> CreatePartyAsync(string name, int maxMembers = 5)
        {
            try
            {
                var response = await _http.PostAsJsonAsync("api/party/create", new
                {
                    Name = name,
                    MaxMembers = maxMembers
                });
                
                if (response.IsSuccessStatusCode)
                {
                    var result = await response.Content.ReadFromJsonAsync<ApiResponse<PartyInfo>>();
                    if (result?.Success == true && result.Data != null)
                    {
                        _currentParty = result.Data;
                        PartyUpdated?.Invoke(this, _currentParty);
                        
                        // 加入SignalR组
                        if (_hubConnection?.State == HubConnectionState.Connected)
                        {
                            await _hubConnection.InvokeAsync("JoinPartyGroup", _currentParty.Id);
                        }
                        
                        return true;
                    }
                }
                
                return false;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "创建队伍失败");
                return false;
            }
        }
        
        public async Task<bool> JoinPartyAsync(string partyId)
        {
            try
            {
                var response = await _http.PostAsJsonAsync("api/party/join", new
                {
                    PartyId = partyId
                });
                
                if (response.IsSuccessStatusCode)
                {
                    var result = await response.Content.ReadFromJsonAsync<ApiResponse<PartyInfo>>();
                    if (result?.Success == true && result.Data != null)
                    {
                        _currentParty = result.Data;
                        PartyUpdated?.Invoke(this, _currentParty);
                        
                        // 加入SignalR组
                        if (_hubConnection?.State == HubConnectionState.Connected)
                        {
                            await _hubConnection.InvokeAsync("JoinPartyGroup", partyId);
                        }
                        
                        return true;
                    }
                }
                
                return false;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "加入队伍失败");
                return false;
            }
        }
        
        public async Task<bool> LeavePartyAsync()
        {
            if (_currentParty == null) return false;
            
            try
            {
                var response = await _http.PostAsync($"api/party/leave/{_currentParty.Id}", null);
                
                if (response.IsSuccessStatusCode)
                {
                    // 离开SignalR组
                    if (_hubConnection?.State == HubConnectionState.Connected)
                    {
                        await _hubConnection.InvokeAsync("LeavePartyGroup", _currentParty.Id);
                    }
                    
                    _currentParty = null;
                    PartyUpdated?.Invoke(this, null!);
                    return true;
                }
                
                return false;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "离开队伍失败");
                return false;
            }
        }
        
        public async Task<bool> InvitePlayerAsync(string playerId)
        {
            if (_currentParty == null) return false;
            
            try
            {
                var response = await _http.PostAsJsonAsync("api/party/invite", new
                {
                    PartyId = _currentParty.Id,
                    PlayerId = playerId
                });
                
                return response.IsSuccessStatusCode;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "邀请玩家失败");
                return false;
            }
        }
        
        public async Task<bool> KickMemberAsync(string memberId)
        {
            if (_currentParty == null) return false;
            
            try
            {
                var response = await _http.PostAsJsonAsync("api/party/kick", new
                {
                    PartyId = _currentParty.Id,
                    MemberId = memberId
                });
                
                return response.IsSuccessStatusCode;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "踢出成员失败");
                return false;
            }
        }
        
        public async Task<bool> PromoteToLeaderAsync(string memberId)
        {
            if (_currentParty == null) return false;
            
            try
            {
                var response = await _http.PostAsJsonAsync("api/party/promote", new
                {
                    PartyId = _currentParty.Id,
                    MemberId = memberId
                });
                
                return response.IsSuccessStatusCode;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "转让队长失败");
                return false;
            }
        }
        
        public async Task<bool> SetReadyStatusAsync(bool isReady)
        {
            if (_currentParty == null) return false;
            
            try
            {
                var response = await _http.PostAsJsonAsync("api/party/ready", new
                {
                    PartyId = _currentParty.Id,
                    IsReady = isReady
                });
                
                return response.IsSuccessStatusCode;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "设置准备状态失败");
                return false;
            }
        }
        
        public async Task<List<PartyInfo>> GetAvailablePartiesAsync()
        {
            try
            {
                var response = await _http.GetFromJsonAsync<ApiResponse<List<PartyInfo>>>("api/party/available");
                if (response?.Success == true && response.Data != null)
                {
                    _availableParties = response.Data;
                    return _availableParties;
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "获取可用队伍列表失败");
            }
            
            return new List<PartyInfo>();
        }
        
        public void UpdatePartyState(PartyInfo party)
        {
            _currentParty = party;
            PartyUpdated?.Invoke(this, party);
        }
        
        public void Dispose()
        {
            _hubConnection?.DisposeAsync().GetAwaiter().GetResult();
        }
    }
}
```

### 文件 6：Services/BattleService.cs
```csharp
using System;
using System.Net.Http;
using System.Net.Http.Json;
using System.Threading.Tasks;
using BlazorIdleGame.Client.Models;
using Microsoft.Extensions.Logging;

namespace BlazorIdleGame.Client.Services
{
    public interface IBattleService
    {
        BattleState? CurrentBattle { get; }
        
        event EventHandler<BattleState>? BattleUpdated;
        event EventHandler<BattleLog>? BattleLogAdded;
        event EventHandler<BattleRewards>? BattleCompleted;
        
        Task InitializeAsync();
        Task<bool> StartBattleAsync(string enemyId, bool isPartyBattle = false);
        Task<bool> FleeBattleAsync();
        Task<bool> UseSkillAsync(string skillId, string targetId);
        void UpdateBattleState(BattleState battle);
        void Dispose();
    }
    
    public class BattleService : IBattleService, IDisposable
    {
        private readonly HttpClient _http;
        private readonly ILogger<BattleService> _logger;
        private BattleState? _currentBattle;
        
        public BattleState? CurrentBattle => _currentBattle;
        
        public event EventHandler<BattleState>? BattleUpdated;
        public event EventHandler<BattleLog>? BattleLogAdded;
        public event EventHandler<BattleRewards>? BattleCompleted;
        
        public BattleService(HttpClient http, ILogger<BattleService> logger)
        {
            _http = http;
            _logger = logger;
        }
        
        public Task InitializeAsync()
        {
            // 初始化战斗服务
            return Task.CompletedTask;
        }
        
        public async Task<bool> StartBattleAsync(string enemyId, bool isPartyBattle = false)
        {
            try
            {
                var response = await _http.PostAsJsonAsync("api/battle/start", new
                {
                    EnemyId = enemyId,
                    IsPartyBattle = isPartyBattle
                });
                
                if (response.IsSuccessStatusCode)
                {
                    var result = await response.Content.ReadFromJsonAsync<ApiResponse<BattleState>>();
                    if (result?.Success == true && result.Data != null)
                    {
                        _currentBattle = result.Data;
                        BattleUpdated?.Invoke(this, _currentBattle);
                        return true;
                    }
                }
                
                return false;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "开始战斗失败");
                return false;
            }
        }
        
        public async Task<bool> FleeBattleAsync()
        {
            if (_currentBattle == null) return false;
            
            try
            {
                var response = await _http.PostAsync($"api/battle/flee/{_currentBattle.BattleId}", null);
                
                if (response.IsSuccessStatusCode)
                {
                    _currentBattle = null;
                    BattleUpdated?.Invoke(this, null!);
                    return true;
                }
                
                return false;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "逃离战斗失败");
                return false;
            }
        }
        
        public async Task<bool> UseSkillAsync(string skillId, string targetId)
        {
            if (_currentBattle == null) return false;
            
            try
            {
                var response = await _http.PostAsJsonAsync("api/battle/skill", new
                {
                    BattleId = _currentBattle.BattleId,
                    SkillId = skillId,
                    TargetId = targetId
                });
                
                return response.IsSuccessStatusCode;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "使用技能失败");
                return false;
            }
        }
        
        public void UpdateBattleState(BattleState battle)
        {
            var previousBattle = _currentBattle;
            _currentBattle = battle;
            
            // 检测新的战斗日志
            if (previousBattle != null && battle.Logs.Count > previousBattle.Logs.Count)
            {
                var newLogs = battle.Logs.Skip(previousBattle.Logs.Count);
                foreach (var log in newLogs)
                {
                    BattleLogAdded?.Invoke(this, log);
                }
            }
            
            // 检测战斗结束
            if (battle.Status == BattleStatus.Victory || battle.Status == BattleStatus.Defeat)
            {
                if (battle.Rewards != null)
                {
                    BattleCompleted?.Invoke(this, battle.Rewards);
                }
            }
            
            BattleUpdated?.Invoke(this, battle);
        }
        
        public void Dispose()
        {
            // 清理资源
        }
    }
}
```