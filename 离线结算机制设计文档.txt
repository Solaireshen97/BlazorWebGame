==================================================
一、目标与核心原则
==================================================
1. 玩家离线后仍然获得合理进度（战斗收益 / 采集 / 生产）。
2. 上线时不出现长时间卡顿（避免一次性逐 tick 重放巨量逻辑）。
3. 防止长期不登录过度囤积资源（封顶 / 衰减）。
4. 逻辑与在线保持一致（公平、抗作弊，可复现）。
5. 可扩展：支持多角色、多活动、组队、多系统（战斗 / 生产 / 采集）。

==================================================
三、最终推荐策略组合
==================================================
1. 最大离线可结算时长上限（如 12h / 24h）。
2. “整段 + 余数”模式：整段后台处理，余数登录补算。
3. 战斗：事件队列（Attack / Skill / BuffExpire），离线时间跳跃推进。
4. 采集 / 生产：周期循环 → k 次完成数 + 余数；若状态动态则回退细化。
5. 多角色：逐角色活动 (Activity) 结算。
6. 组队：全离线 → 队伍战斗离线推进；部分在线 → 在线驱动，离线成员补发。
7. 异常中断：材料不足、节点枯竭即停止或暂停。


==================================================
四、玩家上线结算流程
==================================================
1. rawOffline = now - lastOnline
2. effectiveOffline = min(rawOffline, MaxOfflineLimit)
3. 战斗：
   - 加载战斗实例与事件队列
   - FastForward 到 offlineEnd：执行所有 TriggerTime <= offlineEnd 的事件
   - 战斗结束则结算；未结束保留未来事件
4. 采集 / 生产：
   - duration = 当前实际周期
   - k = floor(effectiveOffline / duration)
   - 发放 k 次产出
   - rem = effectiveOffline % duration → 设置 nextTriggerTime = now + (duration - rem)
   - 若中途可能受资源/随机影响：改为逐次安全校验
5. 汇总奖励写入（经验/货币/掉落/产物）
6. rawOffline > 上限：提示或衰减
7. 返回客户端：活动状态 + nextTriggerTime + 离线收益包


==================================================
五、后台周期 / 队列方案
==================================================
1. 每 N 分钟扫描离线玩家，累计离线时长。
2. 达到结算粒度（如 1h）→ 生成离线结算任务入队。
3. Worker 消费：执行公式或事件推进，写入 pendingRewards。
4. 玩家上线：读取累积 + 补算余数 (< 粒度)。


==================================================
六、事件队列离线推进（战斗）
==================================================
存储：
- 当前 gameClock
- 未来事件（TriggerTime, Type, VersionSnapshot）
- 单位状态（HP, Buff, 下次攻击信息）
推进：
while queue.top.TriggerTime <= offlineEnd:
  pop → AdvanceTo(TriggerTime) → 版本/状态校验 → Execute
最后 AdvanceTo(offlineEnd)，保存新状态与剩余事件。


==================================================
七、统一进度 / 冷却展示
==================================================
进度条公式：
progress = 1 - (nextTriggerTime - serverNow) / totalCycle
适用：下一次攻击 / 下一次采集完成 / 下一次生产完成。
速度变化后：重算 nextTriggerTime，前端即时刷新。


==================================================
八、加速 / 减速 / 重排
==================================================
1. 每个影响时间的状态变更 → Version++
2. 计算当前进度 p = (now - cycleStart) / oldDuration
3. newRemaining = newDuration * (1 - p)
4. nextTriggerTime = now + newRemaining
5. 旧事件：标记失效（取消或版本不匹配即丢弃）


==================================================
九、最大离线与衰减策略
==================================================
- 硬上限：只结算前 12h
==================================================
十、数据持久化最小集合
==================================================
玩家 / 角色：
- lastOnlineTime
- activityType (Combat / Gathering / Production / Idle ...)
- activityContextId
- nextTriggerTime
- version
- pendingOfflineRewards (引用或聚合)
战斗实例：
- gameClock
- 单位快照
- 剩余事件（可裁剪）
生产：
- jobId, recipeId, startTime, plannedFinishTime, stageIndex, version, state
采集：
- nodeId, startTime, nextTriggerTime, 累计产出/进度
节点：
- 当前容量、重生时间


==================================================
十一、反作弊与一致性
==================================================
1. 使用服务器时间，不信任客户端离线时长。
2. 时间回拨检测（lastOnline > now 容差以秒计）。
3. RNG 使用固定种子，可复现。
4. 生产 / 采集材料：建议开始即扣除，避免回滚刷。
5. 多端并发：只允许一个活跃会话执行离线结算。
6. 战斗记录：关键事件日志可重放验证。


==================================================
十二、性能优化
==================================================
1. 优先用公式计算线性部分。
2. 战斗事件压缩：离线期间普通攻击可聚合（可选）。
3. 分层队列：宏观（长周期）与战斗微观分离。
4. 大离线时长：采集/生产直接算 k 次，不循环调度。
5. 对象池：事件/日志条目复用。
6. 延迟激活：远期事件轻量存储，靠时间接近再入热队列。
7. 批量数据库写：聚合写入离线奖励。


==================================================
十三、多人 / 组队
==================================================
1. 全队离线：整体战斗实例按事件队列推进。
2. 部分在线：在线玩家驱动时间；离线成员收益记录 pending。
3. 成员离队：移出实例，独立进入 Idle 或其他活动。
4. 临时掉线：宽限时间内仍算在线；超时才进入离线推进。
5. 战斗结束：统一分配奖励，离线成员上线领取。


==================================================
十四、循环活动统一抽象
==================================================
RecurringActivity：
- 类型：Combat / Gathering / Production
- baseDuration
- calcEffectiveDuration()
- scheduleNext()
- onCycleExecute()
执行模板：
1) 校验状态有效
2) 校验资源 / 背包
3) 发放或结算
4) 计算下一周期并调度（除非终止）


==================================================
十五、迁移步骤建议
==================================================
1. 给现有系统补充 nextTriggerTime 字段。
2. 战斗改为事件队列（先普通攻击）。
3. 生产 / 采集去掉 tick，改用周期事件。
4. 实现 OfflineAdvance(player, offlineEnd)。
5. 加后台分段结算（可选）。
6. 引入最大离线限制 / 衰减策略。
7. 前端统一使用 nextTriggerTime 驱动进度条。
8. 增加日志、压测、旧新结果对比校验。
9. 加反作弊与数据回放工具。


==================================================
十六、采集快速伪逻辑
==================================================
进入采集：
duration = CalcGatherDuration()
nextTrigger = now + duration
状态持久化


离线恢复：
offline = min(now - lastOnline, cap)
while offline >= duration:
  发放一次产出
  offline -= duration
  duration = CalcGatherDuration() (若有动态修改)
if offline > 0:
  nextTrigger = now + (duration - offline)
else:
  nextTrigger = now + duration
保存状态


==================================================
十七、前端统一数据结构（示例）
==================================================
{
  activityType: "Gathering",
  nextTriggerTime: 1712345678901,
  cycleDuration: 6000,
  progress = 1 - (nextTriggerTime - serverNow) / cycleDuration
}


==================================================
十八、常见坑
==================================================
1. 忘记加速 / 减速后重排下一触发时间。
2. 材料延后扣除 → 被利用离线刷材料。
3. 使用系统时间漂移导致进度异常。
4. 战斗内部事件全部持久化 → IO 过大。
5. 背包满仍继续产出 → 产物丢失或循环浪费。
6. 版本号/取消标记使用不一致导致重复执行。
7. 超过上限未提示，玩家误解为系统错误。


==================================================
十九、高级扩展
==================================================
1. 离线收益预览（下线前提示 X 小时收益）。
2. 离线加成道具（在上限内提高效率）。
3. 分档衰减曲线配置化表驱动。
4. 战斗离线关键帧保存 + 上线伪回放。
5. 手动领取模式（背包不足时存待领取池）。
6. 多角色调度优先级（主角色收益加成）。
7. 服务器动态降载：延迟处理低价值离线段。


==================================================
二十、结构参考
==================================================
PlayerState:
- lastOnline
- characters[]


CharacterState:
- activityType
- contextId
- nextTriggerTime
- version
- pendingRewardsRef


OfflineRewardRecord:
- type
- amount
- source
- timeRange


BattleInstance:
- gameClock
- units[]
- eventQueue[]


（采集 / 生产 Job / Node 结构同上所述）


==================================================
总结
==================================================
采用：事件队列驱动战斗 + 循环周期驱动生产采集 + 最大离线上限 + 分段/异步结算 + 上线补余数。统一“下一次触发时间”与版本控制实现高性能、可扩展、可回放且一致的离线奖励系统。