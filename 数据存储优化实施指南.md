# BlazorWebGame 数据存储优化实施指南

## 快速开始 - 30分钟优化方案

### 🚀 立即可执行的改进 (5分钟)

#### 1. 优化数据库连接字符串
```json
// src/BlazorWebGame.Server/appsettings.json
{
  "ConnectionStrings": {
    "DefaultConnection": "Data Source=gamedata.db;Cache=Shared;Pooling=true;Max Pool Size=100;"
  }
}
```

#### 2. 启用SQLite性能优化
```csharp
// src/BlazorWebGame.Server/Data/GameDbContext.cs
protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
{
    if (!optionsBuilder.IsConfigured)
    {
        optionsBuilder.UseSqlite(connectionString, options =>
        {
            options.CommandTimeout(30);
        });
    }
    
    // 性能优化
    optionsBuilder.EnableSensitiveDataLogging(false);
    optionsBuilder.EnableDetailedErrors(false);
}

protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    base.OnModelCreating(modelBuilder);
    
    // 立即可用的索引优化
    modelBuilder.Entity<PlayerEntity>()
        .HasIndex(p => new { p.IsOnline, p.LastActiveAt })
        .HasDatabaseName("IX_Players_Online_LastActive");
        
    modelBuilder.Entity<BattleRecordEntity>()
        .HasIndex(b => new { b.Status, b.StartedAt })
        .HasDatabaseName("IX_BattleRecords_Status_Started");
}
```

### ⚡ 缓存优化 (10分钟)

#### 1. 添加内存缓存服务
```csharp
// src/BlazorWebGame.Server/Services/CachedDataStorageService.cs
public class CachedDataStorageService : IDataStorageService
{
    private readonly IDataStorageService _baseService;
    private readonly IMemoryCache _cache;
    private readonly ILogger<CachedDataStorageService> _logger;
    
    public CachedDataStorageService(
        IDataStorageService baseService, 
        IMemoryCache cache,
        ILogger<CachedDataStorageService> logger)
    {
        _baseService = baseService;
        _cache = cache;
        _logger = logger;
    }
    
    public async Task<PlayerStorageDto?> GetPlayerAsync(string playerId)
    {
        var cacheKey = $"player:{playerId}";
        
        if (_cache.TryGetValue(cacheKey, out PlayerStorageDto cachedPlayer))
        {
            _logger.LogDebug("Cache hit for player {PlayerId}", playerId);
            return cachedPlayer;
        }
        
        var player = await _baseService.GetPlayerAsync(playerId);
        if (player != null)
        {
            var cacheOptions = new MemoryCacheEntryOptions
            {
                AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(15),
                SlidingExpiration = TimeSpan.FromMinutes(5),
                Priority = CacheItemPriority.High,
                Size = 1
            };
            
            _cache.Set(cacheKey, player, cacheOptions);
            _logger.LogDebug("Cached player {PlayerId}", playerId);
        }
        
        return player;
    }
    
    public async Task<ApiResponse<PlayerStorageDto>> SavePlayerAsync(PlayerStorageDto player)
    {
        var result = await _baseService.SavePlayerAsync(player);
        
        if (result.Success)
        {
            // 更新缓存
            var cacheKey = $"player:{player.Id}";
            _cache.Remove(cacheKey);
            _logger.LogDebug("Invalidated cache for player {PlayerId}", player.Id);
        }
        
        return result;
    }
    
    // 实现其他接口方法...
}
```

#### 2. 注册缓存服务
```csharp
// src/BlazorWebGame.Server/Program.cs
builder.Services.AddMemoryCache(options =>
{
    options.SizeLimit = 1000; // 限制缓存项数量
});

// 装饰器模式注册缓存服务
builder.Services.AddScoped<IDataStorageService, ConsolidatedDataStorageService>();
builder.Services.Decorate<IDataStorageService, CachedDataStorageService>();
```

### 🔧 客户端存储改进 (15分钟)

#### 1. 增强GameStorage错误处理
```csharp
// src/BlazorWebGame.Client/Utils/GameStorage.cs
public class GameStorage
{
    private readonly IJSRuntime _js;
    private readonly ILogger<GameStorage> _logger;
    private const string PlayerDataKey = "mygame-player-data";
    private const string GameStateKey = "mygame-game-state";
    
    public GameStorage(IJSRuntime js, ILogger<GameStorage> logger)
    {
        _js = js;
        _logger = logger;
    }
    
    public async Task<T?> GetItemAsync<T>(string key)
    {
        try
        {
            var json = await _js.InvokeAsync<string>("localStorage.getItem", key);
            if (string.IsNullOrEmpty(json))
            {
                _logger.LogDebug("No data found for key: {Key}", key);
                return default;
            }
            
            if (typeof(T) == typeof(string))
            {
                return (T)(object)json;
            }
            
            var result = JsonSerializer.Deserialize<T>(json);
            _logger.LogDebug("Successfully loaded data for key: {Key}", key);
            return result;
        }
        catch (JSException jsEx)
        {
            _logger.LogError(jsEx, "JavaScript error loading data for key: {Key}", key);
            return default;
        }
        catch (JsonException jsonEx)
        {
            _logger.LogError(jsonEx, "JSON deserialization error for key: {Key}", key);
            // 尝试清除损坏的数据
            await RemoveItemAsync(key);
            return default;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Unexpected error loading data for key: {Key}", key);
            return default;
        }
    }
    
    public async Task SetItemAsync<T>(string key, T value)
    {
        try
        {
            var valueToStore = value is string s ? s : JsonSerializer.Serialize(value);
            await _js.InvokeVoidAsync("localStorage.setItem", key, valueToStore);
            _logger.LogDebug("Successfully saved data for key: {Key}", key);
        }
        catch (JSException jsEx) when (jsEx.Message.Contains("QuotaExceededError"))
        {
            _logger.LogWarning(jsEx, "Storage quota exceeded for key: {Key}, attempting cleanup", key);
            await CleanupOldData();
            
            // 重试一次
            try
            {
                var valueToStore = value is string s ? s : JsonSerializer.Serialize(value);
                await _js.InvokeVoidAsync("localStorage.setItem", key, valueToStore);
            }
            catch (Exception retryEx)
            {
                _logger.LogError(retryEx, "Failed to save data after cleanup for key: {Key}", key);
                throw new StorageException($"无法保存数据，存储空间不足: {key}", retryEx);
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error saving data for key: {Key}", key);
            throw new StorageException($"保存数据失败: {key}", ex);
        }
    }
    
    public async Task RemoveItemAsync(string key)
    {
        try
        {
            await _js.InvokeVoidAsync("localStorage.removeItem", key);
            _logger.LogDebug("Successfully removed data for key: {Key}", key);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error removing data for key: {Key}", key);
        }
    }
    
    private async Task CleanupOldData()
    {
        try
        {
            var keysToRemove = new[]
            {
                "old-game-data",
                "temp-battle-state",
                "cached-dungeon-data"
            };
            
            foreach (var key in keysToRemove)
            {
                await RemoveItemAsync(key);
            }
            
            _logger.LogInformation("Cleaned up old localStorage data");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error during localStorage cleanup");
        }
    }
}

public class StorageException : Exception
{
    public StorageException(string message) : base(message) { }
    public StorageException(string message, Exception innerException) : base(message, innerException) { }
}
```

## 📋 完整实施计划

### 第1周: 基础优化

#### 第1天: 数据库优化
- [ ] 更新连接字符串配置
- [ ] 添加关键索引
- [ ] 启用SQLite优化参数
- [ ] 测试查询性能

#### 第2天: 缓存实现
- [ ] 实现CachedDataStorageService
- [ ] 配置内存缓存参数
- [ ] 添加缓存失效机制
- [ ] 测试缓存效果

#### 第3天: 客户端改进
- [ ] 增强GameStorage错误处理
- [ ] 添加存储空间管理
- [ ] 实现数据清理机制
- [ ] 测试离线场景

#### 第4-5天: 监控和日志
- [ ] 添加性能监控
- [ ] 配置结构化日志
- [ ] 实现健康检查
- [ ] 设置警报机制

### 第2周: 架构重构

#### 第6-7天: Repository模式
```csharp
// 1. 创建Repository接口
public interface IPlayerRepository
{
    Task<Player> GetByIdAsync(string id);
    Task<Player> SaveAsync(Player player);
    Task<bool> DeleteAsync(string id);
    Task<List<Player>> GetOnlinePlayersAsync();
    Task<List<Player>> SearchAsync(string searchTerm, int limit);
}

// 2. 实现Repository
public class PlayerRepository : IPlayerRepository
{
    private readonly GameDbContext _context;
    private readonly ILogger<PlayerRepository> _logger;
    
    public PlayerRepository(GameDbContext context, ILogger<PlayerRepository> logger)
    {
        _context = context;
        _logger = logger;
    }
    
    public async Task<Player> GetByIdAsync(string id)
    {
        return await _context.Players
            .FirstOrDefaultAsync(p => p.Id == id);
    }
    
    public async Task<Player> SaveAsync(Player player)
    {
        var existing = await _context.Players.FindAsync(player.Id);
        
        if (existing == null)
        {
            _context.Players.Add(player);
        }
        else
        {
            _context.Entry(existing).CurrentValues.SetValues(player);
        }
        
        await _context.SaveChangesAsync();
        return player;
    }
    
    public async Task<List<Player>> GetOnlinePlayersAsync()
    {
        return await _context.Players
            .Where(p => p.IsOnline)
            .OrderByDescending(p => p.LastActiveAt)
            .ToListAsync();
    }
}
```

#### 第8-9天: 服务层重构
```csharp
// 1. 业务服务接口
public interface IPlayerService
{
    Task<Result<PlayerDto>> GetPlayerAsync(string id);
    Task<Result<PlayerDto>> CreatePlayerAsync(CreatePlayerRequest request);
    Task<Result<PlayerDto>> UpdatePlayerAsync(string id, UpdatePlayerRequest request);
    Task<Result> DeletePlayerAsync(string id);
}

// 2. 业务服务实现
public class PlayerService : IPlayerService
{
    private readonly IPlayerRepository _repository;
    private readonly IMapper _mapper;
    private readonly ILogger<PlayerService> _logger;
    
    public async Task<Result<PlayerDto>> GetPlayerAsync(string id)
    {
        try
        {
            var player = await _repository.GetByIdAsync(id);
            if (player == null)
            {
                return Result<PlayerDto>.NotFound("玩家不存在");
            }
            
            var dto = _mapper.Map<PlayerDto>(player);
            return Result<PlayerDto>.Success(dto);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to get player {PlayerId}", id);
            return Result<PlayerDto>.Error("获取玩家信息失败");
        }
    }
}
```

#### 第10天: 集成测试
- [ ] 编写Repository测试
- [ ] 编写Service测试
- [ ] 性能基准测试
- [ ] 集成测试验证

### 第3周: 高级特性

#### 第11-12天: 数据同步机制
```csharp
public class DataSyncService
{
    private readonly ILocalStorageService _localStorage;
    private readonly IPlayerService _playerService;
    private readonly ILogger<DataSyncService> _logger;
    
    public async Task<SyncResult> SyncPlayerDataAsync(string playerId)
    {
        try
        {
            // 获取本地数据
            var localData = await _localStorage.GetPlayerDataAsync(playerId);
            var serverData = await _playerService.GetPlayerAsync(playerId);
            
            if (!serverData.IsSuccess)
            {
                return SyncResult.Failed("无法获取服务器数据");
            }
            
            // 冲突解决策略
            var resolution = ResolveConflicts(localData, serverData.Data);
            
            switch (resolution.Strategy)
            {
                case ConflictResolution.UseLocal:
                    await _playerService.UpdatePlayerAsync(playerId, localData);
                    break;
                    
                case ConflictResolution.UseServer:
                    await _localStorage.SavePlayerDataAsync(serverData.Data);
                    break;
                    
                case ConflictResolution.Merge:
                    var merged = MergePlayerData(localData, serverData.Data);
                    await _playerService.UpdatePlayerAsync(playerId, merged);
                    await _localStorage.SavePlayerDataAsync(merged);
                    break;
            }
            
            return SyncResult.Success(resolution.Strategy);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Data sync failed for player {PlayerId}", playerId);
            return SyncResult.Failed(ex.Message);
        }
    }
}
```

#### 第13-14天: 批量操作优化
```csharp
public class BatchOperationService
{
    private readonly GameDbContext _context;
    private readonly ILogger<BatchOperationService> _logger;
    
    public async Task<BatchResult<PlayerDto>> SavePlayersAsync(IEnumerable<PlayerDto> players)
    {
        var result = new BatchResult<PlayerDto>();
        var playerList = players.ToList();
        
        // 分批处理，避免内存溢出
        const int batchSize = 100;
        for (int i = 0; i < playerList.Count; i += batchSize)
        {
            var batch = playerList.Skip(i).Take(batchSize);
            await ProcessBatchAsync(batch, result);
        }
        
        return result;
    }
    
    private async Task ProcessBatchAsync(IEnumerable<PlayerDto> batch, BatchResult<PlayerDto> result)
    {
        using var transaction = await _context.Database.BeginTransactionAsync();
        
        try
        {
            foreach (var playerDto in batch)
            {
                var player = _mapper.Map<PlayerEntity>(playerDto);
                _context.Players.Add(player);
                result.SuccessfulItems.Add(playerDto);
            }
            
            await _context.SaveChangesAsync();
            await transaction.CommitAsync();
            
            result.SuccessCount += batch.Count();
        }
        catch (Exception ex)
        {
            await transaction.RollbackAsync();
            _logger.LogError(ex, "Batch operation failed");
            
            foreach (var item in batch)
            {
                result.FailedItems.Add(item);
                result.Errors.Add($"Player {item.Id}: {ex.Message}");
            }
            
            result.ErrorCount += batch.Count();
        }
    }
}
```

#### 第15天: 性能监控
```csharp
public class PerformanceMonitoringService
{
    private readonly ILogger<PerformanceMonitoringService> _logger;
    private readonly IMetrics _metrics;
    
    public async Task<T> MonitorAsync<T>(string operationName, Func<Task<T>> operation)
    {
        using var activity = Activity.StartActivity(operationName);
        var stopwatch = Stopwatch.StartNew();
        
        try
        {
            var result = await operation();
            
            stopwatch.Stop();
            var elapsed = stopwatch.ElapsedMilliseconds;
            
            _metrics.RecordHistogram("operation_duration_ms", elapsed, 
                new KeyValuePair<string, object>("operation", operationName),
                new KeyValuePair<string, object>("status", "success"));
            
            if (elapsed > 1000) // 超过1秒的慢操作
            {
                _logger.LogWarning("Slow operation detected: {Operation} took {ElapsedMs}ms", 
                    operationName, elapsed);
            }
            
            return result;
        }
        catch (Exception ex)
        {
            stopwatch.Stop();
            
            _metrics.RecordHistogram("operation_duration_ms", stopwatch.ElapsedMilliseconds,
                new KeyValuePair<string, object>("operation", operationName),
                new KeyValuePair<string, object>("status", "error"));
            
            _logger.LogError(ex, "Operation failed: {Operation}", operationName);
            throw;
        }
    }
}
```

## 🛠️ 具体代码修改清单

### 1. 立即执行的修改 (今天就可以完成)

#### 修改文件: `src/BlazorWebGame.Server/appsettings.json`
```json
{
  "ConnectionStrings": {
    "DefaultConnection": "Data Source=gamedata.db;Cache=Shared;Pooling=true;Max Pool Size=100;Journal Mode=WAL;Synchronous=NORMAL;Temp Store=MEMORY;"
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.EntityFrameworkCore.Database.Command": "Warning",
      "BlazorWebGame.Server.Services": "Debug"
    }
  }
}
```

#### 修改文件: `src/BlazorWebGame.Server/Program.cs`
```csharp
// 添加这些配置
builder.Services.AddMemoryCache(options =>
{
    options.SizeLimit = 1000;
    options.CompactionPercentage = 0.25;
});

// 配置Entity Framework
builder.Services.AddDbContext<GameDbContext>(options =>
{
    options.UseSqlite(builder.Configuration.GetConnectionString("DefaultConnection"), 
        sqliteOptions =>
        {
            sqliteOptions.CommandTimeout(30);
        });
    
    // 生产环境优化
    if (!builder.Environment.IsDevelopment())
    {
        options.EnableSensitiveDataLogging(false);
        options.EnableDetailedErrors(false);
    }
});

// 添加健康检查
builder.Services.AddHealthChecks()
    .AddDbContextCheck<GameDbContext>("database")
    .AddCheck<StorageHealthCheck>("storage");
```

#### 创建文件: `src/BlazorWebGame.Server/HealthChecks/StorageHealthCheck.cs`
```csharp
public class StorageHealthCheck : IHealthCheck
{
    private readonly IDataStorageService _storageService;
    
    public StorageHealthCheck(IDataStorageService storageService)
    {
        _storageService = storageService;
    }
    
    public async Task<HealthCheckResult> CheckHealthAsync(
        HealthCheckContext context, 
        CancellationToken cancellationToken = default)
    {
        try
        {
            var stats = await _storageService.GetStorageStatsAsync();
            
            if (stats.Success)
            {
                return HealthCheckResult.Healthy("Storage service is healthy", stats.Data);
            }
            
            return HealthCheckResult.Unhealthy("Storage service returned error", 
                new Exception(stats.Message));
        }
        catch (Exception ex)
        {
            return HealthCheckResult.Unhealthy("Storage service check failed", ex);
        }
    }
}
```

### 2. 本周可完成的改进

#### 创建缓存服务装饰器
```bash
# 创建新文件
touch src/BlazorWebGame.Server/Services/CachedDataStorageService.cs
```

#### 添加AutoMapper配置
```bash
# 添加包引用
dotnet add src/BlazorWebGame.Server package AutoMapper.Extensions.Microsoft.DependencyInjection
```

```csharp
// src/BlazorWebGame.Server/Mapping/MappingProfile.cs
public class MappingProfile : Profile
{
    public MappingProfile()
    {
        CreateMap<PlayerEntity, PlayerDto>()
            .ForMember(dest => dest.Attributes, 
                opt => opt.MapFrom(src => JsonSerializer.Deserialize<Dictionary<string, object>>(src.AttributesJson)));
            
        CreateMap<PlayerDto, PlayerEntity>()
            .ForMember(dest => dest.AttributesJson, 
                opt => opt.MapFrom(src => JsonSerializer.Serialize(src.Attributes)));
    }
}
```

## 📊 预期改进效果

### 性能提升预期
- **数据库查询速度**: 提升 50-70%
- **缓存命中率**: 达到 80-90%
- **客户端响应速度**: 提升 40-60%
- **内存使用优化**: 减少 30-40%

### 可维护性改进
- **代码重复减少**: 60%以上
- **单元测试覆盖率**: 达到 80%以上
- **错误处理统一**: 100%标准化
- **日志记录完整**: 全覆盖监控

### 用户体验提升
- **离线支持**: 恢复完整离线功能
- **数据同步**: 自动冲突解决
- **加载速度**: 首次加载提升50%
- **稳定性**: 错误率降低90%

## ✅ 检查清单

### 每日检查
- [ ] 数据库性能监控正常
- [ ] 缓存命中率达标
- [ ] 错误日志无异常
- [ ] API响应时间正常

### 每周检查  
- [ ] 运行完整测试套件
- [ ] 检查数据库大小增长
- [ ] 清理过期缓存数据
- [ ] 更新性能基准

### 每月检查
- [ ] 数据库维护和优化
- [ ] 性能报告生成
- [ ] 容量规划评估
- [ ] 安全审计检查

---

**开始执行**: 选择"立即可执行的改进"部分，30分钟内即可看到显著效果！
