# BlazorWebGame æ•°æ®å­˜å‚¨ä¼˜åŒ–å®æ–½æŒ‡å—

## å¿«é€Ÿå¼€å§‹ - 30åˆ†é’Ÿä¼˜åŒ–æ–¹æ¡ˆ

### ğŸš€ ç«‹å³å¯æ‰§è¡Œçš„æ”¹è¿› (5åˆ†é’Ÿ)

#### 1. ä¼˜åŒ–æ•°æ®åº“è¿æ¥å­—ç¬¦ä¸²
```json
// src/BlazorWebGame.Server/appsettings.json
{
  "ConnectionStrings": {
    "DefaultConnection": "Data Source=gamedata.db;Cache=Shared;Pooling=true;Max Pool Size=100;"
  }
}
```

#### 2. å¯ç”¨SQLiteæ€§èƒ½ä¼˜åŒ–
```csharp
// src/BlazorWebGame.Server/Data/GameDbContext.cs
protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
{
    if (!optionsBuilder.IsConfigured)
    {
        optionsBuilder.UseSqlite(connectionString, options =>
        {
            options.CommandTimeout(30);
        });
    }
    
    // æ€§èƒ½ä¼˜åŒ–
    optionsBuilder.EnableSensitiveDataLogging(false);
    optionsBuilder.EnableDetailedErrors(false);
}

protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    base.OnModelCreating(modelBuilder);
    
    // ç«‹å³å¯ç”¨çš„ç´¢å¼•ä¼˜åŒ–
    modelBuilder.Entity<PlayerEntity>()
        .HasIndex(p => new { p.IsOnline, p.LastActiveAt })
        .HasDatabaseName("IX_Players_Online_LastActive");
        
    modelBuilder.Entity<BattleRecordEntity>()
        .HasIndex(b => new { b.Status, b.StartedAt })
        .HasDatabaseName("IX_BattleRecords_Status_Started");
}
```

### âš¡ ç¼“å­˜ä¼˜åŒ– (10åˆ†é’Ÿ)

#### 1. æ·»åŠ å†…å­˜ç¼“å­˜æœåŠ¡
```csharp
// src/BlazorWebGame.Server/Services/CachedDataStorageService.cs
public class CachedDataStorageService : IDataStorageService
{
    private readonly IDataStorageService _baseService;
    private readonly IMemoryCache _cache;
    private readonly ILogger<CachedDataStorageService> _logger;
    
    public CachedDataStorageService(
        IDataStorageService baseService, 
        IMemoryCache cache,
        ILogger<CachedDataStorageService> logger)
    {
        _baseService = baseService;
        _cache = cache;
        _logger = logger;
    }
    
    public async Task<PlayerStorageDto?> GetPlayerAsync(string playerId)
    {
        var cacheKey = $"player:{playerId}";
        
        if (_cache.TryGetValue(cacheKey, out PlayerStorageDto cachedPlayer))
        {
            _logger.LogDebug("Cache hit for player {PlayerId}", playerId);
            return cachedPlayer;
        }
        
        var player = await _baseService.GetPlayerAsync(playerId);
        if (player != null)
        {
            var cacheOptions = new MemoryCacheEntryOptions
            {
                AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(15),
                SlidingExpiration = TimeSpan.FromMinutes(5),
                Priority = CacheItemPriority.High,
                Size = 1
            };
            
            _cache.Set(cacheKey, player, cacheOptions);
            _logger.LogDebug("Cached player {PlayerId}", playerId);
        }
        
        return player;
    }
    
    public async Task<ApiResponse<PlayerStorageDto>> SavePlayerAsync(PlayerStorageDto player)
    {
        var result = await _baseService.SavePlayerAsync(player);
        
        if (result.Success)
        {
            // æ›´æ–°ç¼“å­˜
            var cacheKey = $"player:{player.Id}";
            _cache.Remove(cacheKey);
            _logger.LogDebug("Invalidated cache for player {PlayerId}", player.Id);
        }
        
        return result;
    }
    
    // å®ç°å…¶ä»–æ¥å£æ–¹æ³•...
}
```

#### 2. æ³¨å†Œç¼“å­˜æœåŠ¡
```csharp
// src/BlazorWebGame.Server/Program.cs
builder.Services.AddMemoryCache(options =>
{
    options.SizeLimit = 1000; // é™åˆ¶ç¼“å­˜é¡¹æ•°é‡
});

// è£…é¥°å™¨æ¨¡å¼æ³¨å†Œç¼“å­˜æœåŠ¡
builder.Services.AddScoped<IDataStorageService, ConsolidatedDataStorageService>();
builder.Services.Decorate<IDataStorageService, CachedDataStorageService>();
```

### ğŸ”§ å®¢æˆ·ç«¯å­˜å‚¨æ”¹è¿› (15åˆ†é’Ÿ)

#### 1. å¢å¼ºGameStorageé”™è¯¯å¤„ç†
```csharp
// src/BlazorWebGame.Client/Utils/GameStorage.cs
public class GameStorage
{
    private readonly IJSRuntime _js;
    private readonly ILogger<GameStorage> _logger;
    private const string PlayerDataKey = "mygame-player-data";
    private const string GameStateKey = "mygame-game-state";
    
    public GameStorage(IJSRuntime js, ILogger<GameStorage> logger)
    {
        _js = js;
        _logger = logger;
    }
    
    public async Task<T?> GetItemAsync<T>(string key)
    {
        try
        {
            var json = await _js.InvokeAsync<string>("localStorage.getItem", key);
            if (string.IsNullOrEmpty(json))
            {
                _logger.LogDebug("No data found for key: {Key}", key);
                return default;
            }
            
            if (typeof(T) == typeof(string))
            {
                return (T)(object)json;
            }
            
            var result = JsonSerializer.Deserialize<T>(json);
            _logger.LogDebug("Successfully loaded data for key: {Key}", key);
            return result;
        }
        catch (JSException jsEx)
        {
            _logger.LogError(jsEx, "JavaScript error loading data for key: {Key}", key);
            return default;
        }
        catch (JsonException jsonEx)
        {
            _logger.LogError(jsonEx, "JSON deserialization error for key: {Key}", key);
            // å°è¯•æ¸…é™¤æŸåçš„æ•°æ®
            await RemoveItemAsync(key);
            return default;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Unexpected error loading data for key: {Key}", key);
            return default;
        }
    }
    
    public async Task SetItemAsync<T>(string key, T value)
    {
        try
        {
            var valueToStore = value is string s ? s : JsonSerializer.Serialize(value);
            await _js.InvokeVoidAsync("localStorage.setItem", key, valueToStore);
            _logger.LogDebug("Successfully saved data for key: {Key}", key);
        }
        catch (JSException jsEx) when (jsEx.Message.Contains("QuotaExceededError"))
        {
            _logger.LogWarning(jsEx, "Storage quota exceeded for key: {Key}, attempting cleanup", key);
            await CleanupOldData();
            
            // é‡è¯•ä¸€æ¬¡
            try
            {
                var valueToStore = value is string s ? s : JsonSerializer.Serialize(value);
                await _js.InvokeVoidAsync("localStorage.setItem", key, valueToStore);
            }
            catch (Exception retryEx)
            {
                _logger.LogError(retryEx, "Failed to save data after cleanup for key: {Key}", key);
                throw new StorageException($"æ— æ³•ä¿å­˜æ•°æ®ï¼Œå­˜å‚¨ç©ºé—´ä¸è¶³: {key}", retryEx);
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error saving data for key: {Key}", key);
            throw new StorageException($"ä¿å­˜æ•°æ®å¤±è´¥: {key}", ex);
        }
    }
    
    public async Task RemoveItemAsync(string key)
    {
        try
        {
            await _js.InvokeVoidAsync("localStorage.removeItem", key);
            _logger.LogDebug("Successfully removed data for key: {Key}", key);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error removing data for key: {Key}", key);
        }
    }
    
    private async Task CleanupOldData()
    {
        try
        {
            var keysToRemove = new[]
            {
                "old-game-data",
                "temp-battle-state",
                "cached-dungeon-data"
            };
            
            foreach (var key in keysToRemove)
            {
                await RemoveItemAsync(key);
            }
            
            _logger.LogInformation("Cleaned up old localStorage data");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error during localStorage cleanup");
        }
    }
}

public class StorageException : Exception
{
    public StorageException(string message) : base(message) { }
    public StorageException(string message, Exception innerException) : base(message, innerException) { }
}
```

## ğŸ“‹ å®Œæ•´å®æ–½è®¡åˆ’

### ç¬¬1å‘¨: åŸºç¡€ä¼˜åŒ–

#### ç¬¬1å¤©: æ•°æ®åº“ä¼˜åŒ–
- [ ] æ›´æ–°è¿æ¥å­—ç¬¦ä¸²é…ç½®
- [ ] æ·»åŠ å…³é”®ç´¢å¼•
- [ ] å¯ç”¨SQLiteä¼˜åŒ–å‚æ•°
- [ ] æµ‹è¯•æŸ¥è¯¢æ€§èƒ½

#### ç¬¬2å¤©: ç¼“å­˜å®ç°
- [ ] å®ç°CachedDataStorageService
- [ ] é…ç½®å†…å­˜ç¼“å­˜å‚æ•°
- [ ] æ·»åŠ ç¼“å­˜å¤±æ•ˆæœºåˆ¶
- [ ] æµ‹è¯•ç¼“å­˜æ•ˆæœ

#### ç¬¬3å¤©: å®¢æˆ·ç«¯æ”¹è¿›
- [ ] å¢å¼ºGameStorageé”™è¯¯å¤„ç†
- [ ] æ·»åŠ å­˜å‚¨ç©ºé—´ç®¡ç†
- [ ] å®ç°æ•°æ®æ¸…ç†æœºåˆ¶
- [ ] æµ‹è¯•ç¦»çº¿åœºæ™¯

#### ç¬¬4-5å¤©: ç›‘æ§å’Œæ—¥å¿—
- [ ] æ·»åŠ æ€§èƒ½ç›‘æ§
- [ ] é…ç½®ç»“æ„åŒ–æ—¥å¿—
- [ ] å®ç°å¥åº·æ£€æŸ¥
- [ ] è®¾ç½®è­¦æŠ¥æœºåˆ¶

### ç¬¬2å‘¨: æ¶æ„é‡æ„

#### ç¬¬6-7å¤©: Repositoryæ¨¡å¼
```csharp
// 1. åˆ›å»ºRepositoryæ¥å£
public interface IPlayerRepository
{
    Task<Player> GetByIdAsync(string id);
    Task<Player> SaveAsync(Player player);
    Task<bool> DeleteAsync(string id);
    Task<List<Player>> GetOnlinePlayersAsync();
    Task<List<Player>> SearchAsync(string searchTerm, int limit);
}

// 2. å®ç°Repository
public class PlayerRepository : IPlayerRepository
{
    private readonly GameDbContext _context;
    private readonly ILogger<PlayerRepository> _logger;
    
    public PlayerRepository(GameDbContext context, ILogger<PlayerRepository> logger)
    {
        _context = context;
        _logger = logger;
    }
    
    public async Task<Player> GetByIdAsync(string id)
    {
        return await _context.Players
            .FirstOrDefaultAsync(p => p.Id == id);
    }
    
    public async Task<Player> SaveAsync(Player player)
    {
        var existing = await _context.Players.FindAsync(player.Id);
        
        if (existing == null)
        {
            _context.Players.Add(player);
        }
        else
        {
            _context.Entry(existing).CurrentValues.SetValues(player);
        }
        
        await _context.SaveChangesAsync();
        return player;
    }
    
    public async Task<List<Player>> GetOnlinePlayersAsync()
    {
        return await _context.Players
            .Where(p => p.IsOnline)
            .OrderByDescending(p => p.LastActiveAt)
            .ToListAsync();
    }
}
```

#### ç¬¬8-9å¤©: æœåŠ¡å±‚é‡æ„
```csharp
// 1. ä¸šåŠ¡æœåŠ¡æ¥å£
public interface IPlayerService
{
    Task<Result<PlayerDto>> GetPlayerAsync(string id);
    Task<Result<PlayerDto>> CreatePlayerAsync(CreatePlayerRequest request);
    Task<Result<PlayerDto>> UpdatePlayerAsync(string id, UpdatePlayerRequest request);
    Task<Result> DeletePlayerAsync(string id);
}

// 2. ä¸šåŠ¡æœåŠ¡å®ç°
public class PlayerService : IPlayerService
{
    private readonly IPlayerRepository _repository;
    private readonly IMapper _mapper;
    private readonly ILogger<PlayerService> _logger;
    
    public async Task<Result<PlayerDto>> GetPlayerAsync(string id)
    {
        try
        {
            var player = await _repository.GetByIdAsync(id);
            if (player == null)
            {
                return Result<PlayerDto>.NotFound("ç©å®¶ä¸å­˜åœ¨");
            }
            
            var dto = _mapper.Map<PlayerDto>(player);
            return Result<PlayerDto>.Success(dto);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to get player {PlayerId}", id);
            return Result<PlayerDto>.Error("è·å–ç©å®¶ä¿¡æ¯å¤±è´¥");
        }
    }
}
```

#### ç¬¬10å¤©: é›†æˆæµ‹è¯•
- [ ] ç¼–å†™Repositoryæµ‹è¯•
- [ ] ç¼–å†™Serviceæµ‹è¯•
- [ ] æ€§èƒ½åŸºå‡†æµ‹è¯•
- [ ] é›†æˆæµ‹è¯•éªŒè¯

### ç¬¬3å‘¨: é«˜çº§ç‰¹æ€§

#### ç¬¬11-12å¤©: æ•°æ®åŒæ­¥æœºåˆ¶
```csharp
public class DataSyncService
{
    private readonly ILocalStorageService _localStorage;
    private readonly IPlayerService _playerService;
    private readonly ILogger<DataSyncService> _logger;
    
    public async Task<SyncResult> SyncPlayerDataAsync(string playerId)
    {
        try
        {
            // è·å–æœ¬åœ°æ•°æ®
            var localData = await _localStorage.GetPlayerDataAsync(playerId);
            var serverData = await _playerService.GetPlayerAsync(playerId);
            
            if (!serverData.IsSuccess)
            {
                return SyncResult.Failed("æ— æ³•è·å–æœåŠ¡å™¨æ•°æ®");
            }
            
            // å†²çªè§£å†³ç­–ç•¥
            var resolution = ResolveConflicts(localData, serverData.Data);
            
            switch (resolution.Strategy)
            {
                case ConflictResolution.UseLocal:
                    await _playerService.UpdatePlayerAsync(playerId, localData);
                    break;
                    
                case ConflictResolution.UseServer:
                    await _localStorage.SavePlayerDataAsync(serverData.Data);
                    break;
                    
                case ConflictResolution.Merge:
                    var merged = MergePlayerData(localData, serverData.Data);
                    await _playerService.UpdatePlayerAsync(playerId, merged);
                    await _localStorage.SavePlayerDataAsync(merged);
                    break;
            }
            
            return SyncResult.Success(resolution.Strategy);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Data sync failed for player {PlayerId}", playerId);
            return SyncResult.Failed(ex.Message);
        }
    }
}
```

#### ç¬¬13-14å¤©: æ‰¹é‡æ“ä½œä¼˜åŒ–
```csharp
public class BatchOperationService
{
    private readonly GameDbContext _context;
    private readonly ILogger<BatchOperationService> _logger;
    
    public async Task<BatchResult<PlayerDto>> SavePlayersAsync(IEnumerable<PlayerDto> players)
    {
        var result = new BatchResult<PlayerDto>();
        var playerList = players.ToList();
        
        // åˆ†æ‰¹å¤„ç†ï¼Œé¿å…å†…å­˜æº¢å‡º
        const int batchSize = 100;
        for (int i = 0; i < playerList.Count; i += batchSize)
        {
            var batch = playerList.Skip(i).Take(batchSize);
            await ProcessBatchAsync(batch, result);
        }
        
        return result;
    }
    
    private async Task ProcessBatchAsync(IEnumerable<PlayerDto> batch, BatchResult<PlayerDto> result)
    {
        using var transaction = await _context.Database.BeginTransactionAsync();
        
        try
        {
            foreach (var playerDto in batch)
            {
                var player = _mapper.Map<PlayerEntity>(playerDto);
                _context.Players.Add(player);
                result.SuccessfulItems.Add(playerDto);
            }
            
            await _context.SaveChangesAsync();
            await transaction.CommitAsync();
            
            result.SuccessCount += batch.Count();
        }
        catch (Exception ex)
        {
            await transaction.RollbackAsync();
            _logger.LogError(ex, "Batch operation failed");
            
            foreach (var item in batch)
            {
                result.FailedItems.Add(item);
                result.Errors.Add($"Player {item.Id}: {ex.Message}");
            }
            
            result.ErrorCount += batch.Count();
        }
    }
}
```

#### ç¬¬15å¤©: æ€§èƒ½ç›‘æ§
```csharp
public class PerformanceMonitoringService
{
    private readonly ILogger<PerformanceMonitoringService> _logger;
    private readonly IMetrics _metrics;
    
    public async Task<T> MonitorAsync<T>(string operationName, Func<Task<T>> operation)
    {
        using var activity = Activity.StartActivity(operationName);
        var stopwatch = Stopwatch.StartNew();
        
        try
        {
            var result = await operation();
            
            stopwatch.Stop();
            var elapsed = stopwatch.ElapsedMilliseconds;
            
            _metrics.RecordHistogram("operation_duration_ms", elapsed, 
                new KeyValuePair<string, object>("operation", operationName),
                new KeyValuePair<string, object>("status", "success"));
            
            if (elapsed > 1000) // è¶…è¿‡1ç§’çš„æ…¢æ“ä½œ
            {
                _logger.LogWarning("Slow operation detected: {Operation} took {ElapsedMs}ms", 
                    operationName, elapsed);
            }
            
            return result;
        }
        catch (Exception ex)
        {
            stopwatch.Stop();
            
            _metrics.RecordHistogram("operation_duration_ms", stopwatch.ElapsedMilliseconds,
                new KeyValuePair<string, object>("operation", operationName),
                new KeyValuePair<string, object>("status", "error"));
            
            _logger.LogError(ex, "Operation failed: {Operation}", operationName);
            throw;
        }
    }
}
```

## ğŸ› ï¸ å…·ä½“ä»£ç ä¿®æ”¹æ¸…å•

### 1. ç«‹å³æ‰§è¡Œçš„ä¿®æ”¹ (ä»Šå¤©å°±å¯ä»¥å®Œæˆ)

#### ä¿®æ”¹æ–‡ä»¶: `src/BlazorWebGame.Server/appsettings.json`
```json
{
  "ConnectionStrings": {
    "DefaultConnection": "Data Source=gamedata.db;Cache=Shared;Pooling=true;Max Pool Size=100;Journal Mode=WAL;Synchronous=NORMAL;Temp Store=MEMORY;"
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.EntityFrameworkCore.Database.Command": "Warning",
      "BlazorWebGame.Server.Services": "Debug"
    }
  }
}
```

#### ä¿®æ”¹æ–‡ä»¶: `src/BlazorWebGame.Server/Program.cs`
```csharp
// æ·»åŠ è¿™äº›é…ç½®
builder.Services.AddMemoryCache(options =>
{
    options.SizeLimit = 1000;
    options.CompactionPercentage = 0.25;
});

// é…ç½®Entity Framework
builder.Services.AddDbContext<GameDbContext>(options =>
{
    options.UseSqlite(builder.Configuration.GetConnectionString("DefaultConnection"), 
        sqliteOptions =>
        {
            sqliteOptions.CommandTimeout(30);
        });
    
    // ç”Ÿäº§ç¯å¢ƒä¼˜åŒ–
    if (!builder.Environment.IsDevelopment())
    {
        options.EnableSensitiveDataLogging(false);
        options.EnableDetailedErrors(false);
    }
});

// æ·»åŠ å¥åº·æ£€æŸ¥
builder.Services.AddHealthChecks()
    .AddDbContextCheck<GameDbContext>("database")
    .AddCheck<StorageHealthCheck>("storage");
```

#### åˆ›å»ºæ–‡ä»¶: `src/BlazorWebGame.Server/HealthChecks/StorageHealthCheck.cs`
```csharp
public class StorageHealthCheck : IHealthCheck
{
    private readonly IDataStorageService _storageService;
    
    public StorageHealthCheck(IDataStorageService storageService)
    {
        _storageService = storageService;
    }
    
    public async Task<HealthCheckResult> CheckHealthAsync(
        HealthCheckContext context, 
        CancellationToken cancellationToken = default)
    {
        try
        {
            var stats = await _storageService.GetStorageStatsAsync();
            
            if (stats.Success)
            {
                return HealthCheckResult.Healthy("Storage service is healthy", stats.Data);
            }
            
            return HealthCheckResult.Unhealthy("Storage service returned error", 
                new Exception(stats.Message));
        }
        catch (Exception ex)
        {
            return HealthCheckResult.Unhealthy("Storage service check failed", ex);
        }
    }
}
```

### 2. æœ¬å‘¨å¯å®Œæˆçš„æ”¹è¿›

#### åˆ›å»ºç¼“å­˜æœåŠ¡è£…é¥°å™¨
```bash
# åˆ›å»ºæ–°æ–‡ä»¶
touch src/BlazorWebGame.Server/Services/CachedDataStorageService.cs
```

#### æ·»åŠ AutoMapperé…ç½®
```bash
# æ·»åŠ åŒ…å¼•ç”¨
dotnet add src/BlazorWebGame.Server package AutoMapper.Extensions.Microsoft.DependencyInjection
```

```csharp
// src/BlazorWebGame.Server/Mapping/MappingProfile.cs
public class MappingProfile : Profile
{
    public MappingProfile()
    {
        CreateMap<PlayerEntity, PlayerDto>()
            .ForMember(dest => dest.Attributes, 
                opt => opt.MapFrom(src => JsonSerializer.Deserialize<Dictionary<string, object>>(src.AttributesJson)));
            
        CreateMap<PlayerDto, PlayerEntity>()
            .ForMember(dest => dest.AttributesJson, 
                opt => opt.MapFrom(src => JsonSerializer.Serialize(src.Attributes)));
    }
}
```

## ğŸ“Š é¢„æœŸæ”¹è¿›æ•ˆæœ

### æ€§èƒ½æå‡é¢„æœŸ
- **æ•°æ®åº“æŸ¥è¯¢é€Ÿåº¦**: æå‡ 50-70%
- **ç¼“å­˜å‘½ä¸­ç‡**: è¾¾åˆ° 80-90%
- **å®¢æˆ·ç«¯å“åº”é€Ÿåº¦**: æå‡ 40-60%
- **å†…å­˜ä½¿ç”¨ä¼˜åŒ–**: å‡å°‘ 30-40%

### å¯ç»´æŠ¤æ€§æ”¹è¿›
- **ä»£ç é‡å¤å‡å°‘**: 60%ä»¥ä¸Š
- **å•å…ƒæµ‹è¯•è¦†ç›–ç‡**: è¾¾åˆ° 80%ä»¥ä¸Š
- **é”™è¯¯å¤„ç†ç»Ÿä¸€**: 100%æ ‡å‡†åŒ–
- **æ—¥å¿—è®°å½•å®Œæ•´**: å…¨è¦†ç›–ç›‘æ§

### ç”¨æˆ·ä½“éªŒæå‡
- **ç¦»çº¿æ”¯æŒ**: æ¢å¤å®Œæ•´ç¦»çº¿åŠŸèƒ½
- **æ•°æ®åŒæ­¥**: è‡ªåŠ¨å†²çªè§£å†³
- **åŠ è½½é€Ÿåº¦**: é¦–æ¬¡åŠ è½½æå‡50%
- **ç¨³å®šæ€§**: é”™è¯¯ç‡é™ä½90%

## âœ… æ£€æŸ¥æ¸…å•

### æ¯æ—¥æ£€æŸ¥
- [ ] æ•°æ®åº“æ€§èƒ½ç›‘æ§æ­£å¸¸
- [ ] ç¼“å­˜å‘½ä¸­ç‡è¾¾æ ‡
- [ ] é”™è¯¯æ—¥å¿—æ— å¼‚å¸¸
- [ ] APIå“åº”æ—¶é—´æ­£å¸¸

### æ¯å‘¨æ£€æŸ¥  
- [ ] è¿è¡Œå®Œæ•´æµ‹è¯•å¥—ä»¶
- [ ] æ£€æŸ¥æ•°æ®åº“å¤§å°å¢é•¿
- [ ] æ¸…ç†è¿‡æœŸç¼“å­˜æ•°æ®
- [ ] æ›´æ–°æ€§èƒ½åŸºå‡†

### æ¯æœˆæ£€æŸ¥
- [ ] æ•°æ®åº“ç»´æŠ¤å’Œä¼˜åŒ–
- [ ] æ€§èƒ½æŠ¥å‘Šç”Ÿæˆ
- [ ] å®¹é‡è§„åˆ’è¯„ä¼°
- [ ] å®‰å…¨å®¡è®¡æ£€æŸ¥

---

**å¼€å§‹æ‰§è¡Œ**: é€‰æ‹©"ç«‹å³å¯æ‰§è¡Œçš„æ”¹è¿›"éƒ¨åˆ†ï¼Œ30åˆ†é’Ÿå†…å³å¯çœ‹åˆ°æ˜¾è‘—æ•ˆæœï¼
