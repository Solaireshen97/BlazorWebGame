# BlazorWebGame 用户认证数据存储技术实现文档

## 概述

本文档详细描述了 BlazorWebGame 项目中用户认证和数据存储系统的完整技术实现。系统采用现代的技术栈，实现了安全的用户注册、登录功能，以及高效的数据存储架构。

## 1. 技术架构概览

### 1.1 技术栈
- **数据库**: SQLite 3.x (生产环境可切换到 SQL Server/PostgreSQL)
- **ORM**: Entity Framework Core 8.0
- **Web框架**: ASP.NET Core 8.0 Web API
- **认证**: JWT (JSON Web Tokens)
- **密码加密**: SHA-256 + Salt
- **缓存**: IMemoryCache
- **日志**: Serilog

### 1.2 系统架构图

```
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│   Blazor Client │────▶│   Web API       │────▶│   SQLite DB     │
│                 │     │   (ASP.NET Core)│     │                 │
├─────────────────┤     ├─────────────────┤     ├─────────────────┤
│ • Registration  │     │ • AuthController│     │ • Users         │
│ • Login         │     │ • UserService   │     │ • Players       │
│ • JWT Storage   │     │ • JWT Auth      │     │ • Teams         │
└─────────────────┘     └─────────────────┘     └─────────────────┘
```

## 2. 数据模型设计

### 2.1 用户实体 (UserEntity)

```csharp
public class UserEntity : BaseEntity
{
    public string Username { get; set; } = string.Empty;      // 用户名(唯一)
    public string Email { get; set; } = string.Empty;         // 邮箱(唯一)
    public string PasswordHash { get; set; } = string.Empty;  // 密码哈希
    public string Salt { get; set; } = string.Empty;          // 密码盐值
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow; // 创建时间
    public DateTime LastLoginAt { get; set; } = DateTime.UtcNow; // 最后登录
    public bool IsActive { get; set; } = true;                // 账号状态
    public string Roles { get; set; } = "Player";             // 用户角色(JSON)
    public string RefreshToken { get; set; } = string.Empty;  // 刷新令牌
    public DateTime? RefreshTokenExpiryTime { get; set; }     // 令牌过期时间
}
```

### 2.2 玩家实体 (PlayerEntity)

```csharp
public class PlayerEntity : BaseEntity
{
    public string UserId { get; set; } = string.Empty;        // 关联用户ID
    public string Name { get; set; } = string.Empty;          // 角色名
    public int Level { get; set; } = 1;                       // 等级
    public int Experience { get; set; } = 0;                  // 经验值
    public int Health { get; set; } = 100;                    // 生命值
    public int MaxHealth { get; set; } = 100;                 // 最大生命值
    public int Gold { get; set; } = 0;                        // 金币
    public string SelectedBattleProfession { get; set; } = "Warrior"; // 职业
    public string CurrentAction { get; set; } = "Idle";       // 当前动作
    public string? CurrentActionTargetId { get; set; }        // 目标ID
    public Guid? PartyId { get; set; }                        // 队伍ID
    public bool IsOnline { get; set; } = true;                // 在线状态
    public DateTime LastActiveAt { get; set; } = DateTime.UtcNow; // 最后活动时间
    
    // JSON序列化的复杂属性
    public string AttributesJson { get; set; } = "{}";        // 属性数据
    public string InventoryJson { get; set; } = "[]";         // 背包数据
    public string SkillsJson { get; set; } = "[]";            // 技能数据
    public string EquipmentJson { get; set; } = "{}";         // 装备数据
}
```

### 2.3 数据库表结构关系

```sql
-- 用户表
CREATE TABLE Users (
    Id TEXT PRIMARY KEY,
    Username TEXT UNIQUE NOT NULL,
    Email TEXT UNIQUE NOT NULL,
    PasswordHash TEXT NOT NULL,
    Salt TEXT NOT NULL,
    CreatedAt DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    LastLoginAt DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    IsActive BOOLEAN NOT NULL DEFAULT 1,
    Roles TEXT NOT NULL DEFAULT "Player",
    RefreshToken TEXT,
    RefreshTokenExpiryTime DATETIME,
    UpdatedAt DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- 玩家表
CREATE TABLE Players (
    Id TEXT PRIMARY KEY,
    UserId TEXT NOT NULL,
    Name TEXT UNIQUE NOT NULL,
    Level INTEGER NOT NULL DEFAULT 1,
    Experience INTEGER NOT NULL DEFAULT 0,
    Health INTEGER NOT NULL DEFAULT 100,
    MaxHealth INTEGER NOT NULL DEFAULT 100,
    Gold INTEGER NOT NULL DEFAULT 0,
    SelectedBattleProfession TEXT NOT NULL DEFAULT "Warrior",
    CurrentAction TEXT NOT NULL DEFAULT "Idle",
    CurrentActionTargetId TEXT,
    PartyId TEXT,
    IsOnline BOOLEAN NOT NULL DEFAULT 1,
    LastActiveAt DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    AttributesJson TEXT NOT NULL DEFAULT "{}",
    InventoryJson TEXT NOT NULL DEFAULT "[]",
    SkillsJson TEXT NOT NULL DEFAULT "[]",
    EquipmentJson TEXT NOT NULL DEFAULT "{}",
    CreatedAt DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    UpdatedAt DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (UserId) REFERENCES Users(Id) ON DELETE CASCADE
);
```

## 3. 用户认证服务实现

### 3.1 用户服务接口 (IUserService)

```csharp
public interface IUserService
{
    Task<UserEntity?> GetByIdAsync(string userId);
    Task<UserEntity?> GetByUsernameAsync(string username);
    Task<UserEntity?> GetByEmailAsync(string email);
    Task<UserEntity?> ValidateUserAsync(string username, string password);
    Task<UserEntity> CreateUserAsync(string username, string email, string password, List<string>? roles = null);
    Task<bool> UpdateUserAsync(UserEntity user);
    Task<bool> UpdateRefreshTokenAsync(string userId, string refreshToken, DateTime expiryTime);
    Task<bool> IsUsernameAvailableAsync(string username);
    Task<bool> IsEmailAvailableAsync(string email);
    Task<bool> DeactivateUserAsync(string userId);
    Task UpdateLastLoginAsync(string userId);
}
```

### 3.2 密码安全处理

系统采用 SHA-256 + 随机盐值的方式来确保密码安全：

```csharp
// 生成随机盐值
private static string GenerateSalt()
{
    var saltBytes = new byte[32];
    using (var rng = RandomNumberGenerator.Create())
    {
        rng.GetBytes(saltBytes);
    }
    return Convert.ToBase64String(saltBytes);
}

// 哈希密码
private static string HashPassword(string password, string salt)
{
    var saltBytes = Convert.FromBase64String(salt);
    var passwordBytes = Encoding.UTF8.GetBytes(password);
    
    var combined = new byte[saltBytes.Length + passwordBytes.Length];
    Buffer.BlockCopy(saltBytes, 0, combined, 0, saltBytes.Length);
    Buffer.BlockCopy(passwordBytes, 0, combined, saltBytes.Length, passwordBytes.Length);

    using (var sha256 = SHA256.Create())
    {
        var hashBytes = sha256.ComputeHash(combined);
        return Convert.ToBase64String(hashBytes);
    }
}

// 验证密码
private static bool VerifyPassword(string password, string passwordHash, string salt)
{
    var computedHash = HashPassword(password, salt);
    return computedHash == passwordHash;
}
```

### 3.3 JWT 认证实现

JWT 令牌生成和验证：

```csharp
public string GenerateAccessToken(string userId, string username, List<string>? roles = null)
{
    var claims = new List<Claim>
    {
        new(ClaimTypes.NameIdentifier, userId),
        new(ClaimTypes.Name, username),
        new("UserId", userId),
        new("Username", username),
        new(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString()),
        new(JwtRegisteredClaimNames.Iat, DateTimeOffset.UtcNow.ToUnixTimeSeconds().ToString(), ClaimValueTypes.Integer64)
    };

    // 添加角色声明
    if (roles != null && roles.Any())
    {
        claims.AddRange(roles.Select(role => new Claim(ClaimTypes.Role, role)));
    }

    var tokenDescriptor = new SecurityTokenDescriptor
    {
        Subject = new ClaimsIdentity(claims),
        Expires = DateTime.UtcNow.AddMinutes(GetTokenExpirationMinutes()),
        Issuer = _configuration["Jwt:Issuer"],
        Audience = _configuration["Jwt:Audience"],
        SigningCredentials = new SigningCredentials(_signingKey, SecurityAlgorithms.HmacSha256)
    };

    var tokenHandler = new JwtSecurityTokenHandler();
    var token = tokenHandler.CreateToken(tokenDescriptor);
    return tokenHandler.WriteToken(token);
}
```

## 4. API 接口实现

### 4.1 认证控制器 (AuthController)

#### 用户注册 API

```http
POST /api/auth/register
Content-Type: application/json

{
    "username": "testuser",
    "email": "testuser@example.com",
    "password": "securepassword123"
}
```

**响应示例:**
```json
{
    "success": true,
    "data": {
        "accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
        "refreshToken": "b4c8a2f1e3d6a9b7c4e8f2d5a1b3c6e9",
        "userId": "user-12345678-abcd-efgh-ijkl-123456789012",
        "username": "testuser",
        "roles": ["Player"]
    },
    "message": "Registration successful",
    "timestamp": "2024-01-15T10:30:00.000Z"
}
```

#### 用户登录 API

```http
POST /api/auth/login
Content-Type: application/json

{
    "username": "testuser",
    "password": "securepassword123"
}
```

**响应示例:**
```json
{
    "success": true,
    "data": {
        "accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
        "refreshToken": "a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6",
        "userId": "user-12345678-abcd-efgh-ijkl-123456789012",
        "username": "testuser",
        "roles": ["Player"]
    },
    "message": "Login successful",
    "timestamp": "2024-01-15T10:35:00.000Z"
}
```

#### 刷新令牌 API

```http
POST /api/auth/refresh
Content-Type: application/json

{
    "refreshToken": "a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6",
    "userId": "user-12345678-abcd-efgh-ijkl-123456789012"
}
```

#### 获取当前用户信息 API

```http
GET /api/auth/me
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

**响应示例:**
```json
{
    "success": true,
    "data": {
        "userId": "user-12345678-abcd-efgh-ijkl-123456789012",
        "username": "testuser",
        "roles": ["Player"]
    },
    "message": "User information retrieved successfully",
    "timestamp": "2024-01-15T10:40:00.000Z"
}
```

### 4.2 错误处理

系统实现了统一的错误处理机制：

```json
{
    "success": false,
    "message": "Username is already taken",
    "timestamp": "2024-01-15T10:30:00.000Z"
}
```

常见错误代码：
- `400 Bad Request`: 请求参数错误
- `401 Unauthorized`: 认证失败
- `403 Forbidden`: 权限不足
- `409 Conflict`: 资源冲突（如用户名已存在）
- `500 Internal Server Error`: 服务器内部错误

## 5. 数据库配置和优化

### 5.1 Entity Framework 配置

```csharp
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    // 配置用户实体
    modelBuilder.Entity<UserEntity>(entity =>
    {
        entity.HasKey(e => e.Id);
        entity.Property(e => e.Id).HasMaxLength(50);
        entity.Property(e => e.Username).HasMaxLength(50).IsRequired();
        entity.Property(e => e.Email).HasMaxLength(255).IsRequired();
        entity.Property(e => e.PasswordHash).HasMaxLength(255).IsRequired();
        entity.Property(e => e.Salt).HasMaxLength(255).IsRequired();
        entity.Property(e => e.Roles).HasMaxLength(500).HasDefaultValue("Player");
        entity.Property(e => e.RefreshToken).HasMaxLength(255);
        
        // 唯一约束
        entity.HasIndex(e => e.Username).IsUnique();
        entity.HasIndex(e => e.Email).IsUnique();
        
        // 性能优化索引
        entity.HasIndex(e => e.IsActive);
        entity.HasIndex(e => e.LastLoginAt);
        entity.HasIndex(e => e.CreatedAt);
        entity.HasIndex(e => new { e.Username, e.IsActive });
    });

    // 配置玩家实体
    modelBuilder.Entity<PlayerEntity>(entity =>
    {
        // 外键关系
        entity.HasOne<UserEntity>()
            .WithMany()
            .HasForeignKey(e => e.UserId)
            .OnDelete(DeleteBehavior.Cascade);
        
        // 性能优化索引
        entity.HasIndex(e => e.UserId);
        entity.HasIndex(e => e.Name).IsUnique();
        entity.HasIndex(e => new { e.UserId, e.IsOnline });
    });
}
```

### 5.2 连接字符串配置

```json
{
  "ConnectionStrings": {
    "DefaultConnection": "Data Source=gamedata.db;Cache=Shared;Mode=ReadWriteCreate;"
  }
}
```

### 5.3 SQLite 性能优化

```csharp
protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
{
    if (!optionsBuilder.IsConfigured)
    {
        optionsBuilder.UseSqlite(connectionString, options =>
        {
            options.CommandTimeout(30);
        });
    }
    
    // SQLite 性能优化
    optionsBuilder.EnableServiceProviderCaching();
    optionsBuilder.EnableSensitiveDataLogging(false);
}
```

## 6. 安全考虑

### 6.1 密码安全
- 使用 SHA-256 算法加密密码
- 每个密码使用唯一的随机盐值
- 密码最小长度要求（6个字符）
- 密码不在日志中记录

### 6.2 JWT 安全
- 访问令牌有效期：60分钟
- 刷新令牌有效期：7天
- 令牌使用强随机密钥签名
- 支持令牌撤销机制

### 6.3 API 安全
- 所有敏感API需要JWT认证
- 实现速率限制防止暴力攻击
- 详细的安全日志记录
- IP地址跟踪和记录

### 6.4 数据库安全
- 用户输入参数化查询防止SQL注入
- 数据库连接字符串加密存储
- 定期数据备份
- 敏感数据字段加密

## 7. 测试实现

### 7.1 单元测试覆盖

项目包含完整的用户服务测试套件：

```csharp
public static class UserServiceTests
{
    // 用户注册功能测试
    public static async Task TestUserRegistration(IServiceProvider serviceProvider, ILogger logger);
    
    // 用户登录功能测试
    public static async Task TestUserLogin(IServiceProvider serviceProvider, ILogger logger);
    
    // 用户管理功能测试
    public static async Task TestUserManagement(IServiceProvider serviceProvider, ILogger logger);
    
    // 性能基准测试
    public static async Task RunPerformanceBenchmark(IServiceProvider serviceProvider, ILogger logger);
}
```

### 7.2 测试场景覆盖

- ✅ 用户注册（正常流程）
- ✅ 用户名唯一性验证
- ✅ 邮箱唯一性验证
- ✅ 密码加密验证
- ✅ 用户登录（正确凭据）
- ✅ 用户登录（错误凭据）
- ✅ 刷新令牌更新
- ✅ 用户停用功能
- ✅ 最后登录时间更新
- ✅ 批量操作性能测试

### 7.3 性能基准

在标准开发环境下的性能基准：
- 用户创建：平均 ~5ms/用户
- 用户查询：平均 ~2ms/用户
- 密码验证：平均 ~8ms/用户

## 8. 部署和运维

### 8.1 环境配置

**开发环境:**
```json
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "Jwt": {
    "Key": "development-key-32-characters-long",
    "Issuer": "BlazorWebGame",
    "Audience": "BlazorWebGameClient",
    "ExpireMinutes": 60
  }
}
```

**生产环境:**
```json
{
  "Logging": {
    "LogLevel": {
      "Default": "Warning"
    }
  },
  "Jwt": {
    "Key": "${JWT_SECRET_KEY}",
    "Issuer": "BlazorWebGame",
    "Audience": "BlazorWebGameClient",
    "ExpireMinutes": 30
  }
}
```

### 8.2 监控和日志

系统实现了完整的日志记录：

```csharp
// 用户操作日志
_logger.LogInformation("User {Username} (ID: {UserId}) logged in successfully from IP: {ClientIp}", 
    user.Username, user.Id, GetClientIpAddress());

// 安全事件日志
_logger.LogWarning("Login failed for username: {Username} from IP: {ClientIp}", 
    request.Username, GetClientIpAddress());

// 错误日志
_logger.LogError(ex, "Error during registration for username: {Username}", request.Username);
```

### 8.3 备份策略

- 数据库每日自动备份
- 关键配置文件版本控制
- 用户数据定期导出
- 灾难恢复预案

## 9. API 使用示例

### 9.1 C# 客户端示例

```csharp
public class AuthApiClient
{
    private readonly HttpClient _httpClient;
    
    public async Task<AuthResponse> RegisterAsync(string username, string email, string password)
    {
        var request = new RegisterRequest
        {
            Username = username,
            Email = email,
            Password = password
        };
        
        var response = await _httpClient.PostAsJsonAsync("/api/auth/register", request);
        return await response.Content.ReadFromJsonAsync<AuthResponse>();
    }
    
    public async Task<AuthResponse> LoginAsync(string username, string password)
    {
        var request = new LoginRequest
        {
            Username = username,
            Password = password
        };
        
        var response = await _httpClient.PostAsJsonAsync("/api/auth/login", request);
        return await response.Content.ReadFromJsonAsync<AuthResponse>();
    }
}
```

### 9.2 JavaScript 客户端示例

```javascript
class AuthApiClient {
    constructor(baseUrl) {
        this.baseUrl = baseUrl;
    }
    
    async register(username, email, password) {
        const response = await fetch(`${this.baseUrl}/api/auth/register`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                username,
                email,
                password
            })
        });
        
        return await response.json();
    }
    
    async login(username, password) {
        const response = await fetch(`${this.baseUrl}/api/auth/login`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                username,
                password
            })
        });
        
        return await response.json();
    }
}
```

## 10. 故障排除

### 10.1 常见问题

**问题1: 用户注册失败**
- 检查用户名是否已存在
- 检查邮箱格式是否正确
- 检查密码长度是否符合要求
- 查看服务器日志获取详细错误信息

**问题2: 登录失败**
- 确认用户名和密码正确
- 检查用户账号是否被停用
- 验证数据库连接是否正常
- 检查JWT配置是否正确

**问题3: 令牌验证失败**
- 检查令牌是否过期
- 验证JWT密钥配置
- 确认令牌格式正确
- 检查系统时间同步

### 10.2 调试工具

- 使用 Swagger UI 测试 API
- 查看应用程序日志
- 检查数据库状态
- 使用开发者工具查看网络请求

## 11. 总结

BlazorWebGame 的用户认证数据存储系统实现了：

✅ **完整的用户管理功能**
- 安全的用户注册和登录
- 密码加密和安全存储
- JWT 令牌认证和刷新

✅ **高性能数据存储**
- SQLite 数据库优化配置
- Entity Framework Core 高效查询
- 数据库索引和查询优化

✅ **全面的安全保护**
- 密码哈希和盐值加密
- JWT 令牌安全机制
- API 速率限制和监控

✅ **完整的测试覆盖**
- 单元测试和集成测试
- 性能基准测试
- 自动化测试清理

✅ **生产级部署支持**
- 环境配置管理
- 日志监控系统
- 错误处理和恢复

该系统为 BlazorWebGame 提供了稳定、安全、高性能的用户认证和数据存储基础，支持游戏的用户管理需求，并为后续功能扩展奠定了坚实基础。