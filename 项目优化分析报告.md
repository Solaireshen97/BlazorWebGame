# BlazorWebGame é¡¹ç›®ä¼˜åŒ–åˆ†ææŠ¥å‘Š

## ğŸ¯ ä¼˜åŒ–æ¦‚è¿°

åŸºäºå¯¹BlazorWebGameæœåŠ¡ç«¯çš„æ·±å…¥åˆ†æï¼Œæœ¬æŠ¥å‘Šä»æ€§èƒ½ã€æ¶æ„ã€å®‰å…¨ã€è¿ç»´ç­‰å¤šä¸ªç»´åº¦æå‡ºä¼˜åŒ–å»ºè®®ï¼Œæ—¨åœ¨æå‡ç³»ç»Ÿçš„ç¨³å®šæ€§ã€æ€§èƒ½å’Œå¯ç»´æŠ¤æ€§ã€‚

## ğŸ“Š å½“å‰çŠ¶æ€è¯„ä¼°

### âœ… ç°æœ‰ä¼˜åŠ¿
1. **ç°ä»£åŒ–æŠ€æœ¯æ ˆ**: .NET 8.0 + ASP.NET Core + SignalR
2. **å®Œæ•´çš„åŠŸèƒ½æ¨¡å—**: è¦†ç›–æ¸¸æˆæ ¸å¿ƒåŠŸèƒ½
3. **å®‰å…¨æœºåˆ¶å®Œå–„**: JWTè®¤è¯ã€æƒé™éªŒè¯ã€é€Ÿç‡é™åˆ¶
4. **äº‹ä»¶é©±åŠ¨æ¶æ„**: ç»Ÿä¸€äº‹ä»¶ç³»ç»Ÿ
5. **è‰¯å¥½çš„å¯è§‚æµ‹æ€§**: æ—¥å¿—ã€ç›‘æ§ã€å¥åº·æ£€æŸ¥

### âš ï¸ å¾…ä¼˜åŒ–é—®é¢˜
1. **æ•°æ®æŒä¹…åŒ–**: ç›®å‰ä¸»è¦ä½¿ç”¨å†…å­˜å­˜å‚¨
2. **ç¼“å­˜ç­–ç•¥**: ç¼ºä¹ç³»ç»Ÿæ€§çš„ç¼“å­˜æ–¹æ¡ˆ
3. **å¹¶å‘æ§åˆ¶**: é«˜å¹¶å‘åœºæ™¯ä¸‹çš„æ•°æ®ä¸€è‡´æ€§
4. **æ€§èƒ½ç“¶é¢ˆ**: éƒ¨åˆ†åŒæ­¥æ“ä½œå½±å“å“åº”æ—¶é—´
5. **é”™è¯¯å¤„ç†**: éƒ¨åˆ†å¼‚æ­¥æ–¹æ³•ç¼ºå°‘awaitæ“ä½œç¬¦

## ğŸš€ ä¼˜åŒ–æ–¹å‘å’Œå»ºè®®

### 1. æ•°æ®å­˜å‚¨ä¼˜åŒ–

#### ğŸ¯ å½“å‰é—®é¢˜
- ä¸»è¦ä½¿ç”¨å†…å­˜å­˜å‚¨ï¼Œæ•°æ®æ˜“ä¸¢å¤±
- ç¼ºä¹æ•°æ®æŒä¹…åŒ–ç­–ç•¥
- é‡å¯åæ•°æ®å…¨éƒ¨ä¸¢å¤±

#### ğŸ’¡ ä¼˜åŒ–æ–¹æ¡ˆ

**1.1 å¼•å…¥æ•°æ®åº“æ”¯æŒ**
```csharp
// æ·»åŠ Entity Framework Coreæ”¯æŒ
services.AddDbContext<GameDbContext>(options =>
    options.UseSqlServer(connectionString, b => 
        b.MigrationsAssembly("BlazorWebGame.Server")));

// é…ç½®æ•°æ®åº“è¿æ¥æ± 
services.AddDbContextPool<GameDbContext>(options =>
    options.UseSqlServer(connectionString), poolSize: 128);
```

**1.2 å®ç°åˆ†å±‚å­˜å‚¨ç­–ç•¥**
```csharp
public interface IDataStorageStrategy
{
    Task<T> GetAsync<T>(string key);
    Task SetAsync<T>(string key, T value, TimeSpan? expiry = null);
    Task RemoveAsync(string key);
}

// å†…å­˜ + Redis + æ•°æ®åº“ä¸‰å±‚å­˜å‚¨
public class HybridStorageStrategy : IDataStorageStrategy
{
    private readonly IMemoryCache _memoryCache;
    private readonly IDistributedCache _distributedCache;
    private readonly GameDbContext _dbContext;
    
    // å®ç°æ™ºèƒ½ç¼“å­˜ç­–ç•¥
}
```

**1.3 æ•°æ®åº“æ¶æ„è®¾è®¡**
```sql
-- ç”¨æˆ·è¡¨
CREATE TABLE Users (
    Id UNIQUEIDENTIFIER PRIMARY KEY DEFAULT NEWID(),
    Username NVARCHAR(50) NOT NULL UNIQUE,
    PasswordHash NVARCHAR(255) NOT NULL,
    Email NVARCHAR(100),
    CreatedAt DATETIME2 DEFAULT GETUTCDATE(),
    LastLoginAt DATETIME2,
    IsActive BIT DEFAULT 1,
    INDEX IX_Users_Username (Username),
    INDEX IX_Users_Email (Email)
);

-- è§’è‰²è¡¨
CREATE TABLE Characters (
    Id UNIQUEIDENTIFIER PRIMARY KEY DEFAULT NEWID(),
    UserId UNIQUEIDENTIFIER NOT NULL,
    Name NVARCHAR(50) NOT NULL,
    Class NVARCHAR(20) NOT NULL,
    Level INT NOT NULL DEFAULT 1,
    Experience BIGINT NOT NULL DEFAULT 0,
    Health INT NOT NULL DEFAULT 100,
    MaxHealth INT NOT NULL DEFAULT 100,
    Attributes NVARCHAR(MAX), -- JSONæ ¼å¼å­˜å‚¨å±æ€§
    Position NVARCHAR(100), -- JSONæ ¼å¼å­˜å‚¨åæ ‡
    CreatedAt DATETIME2 DEFAULT GETUTCDATE(),
    LastActiveAt DATETIME2 DEFAULT GETUTCDATE(),
    FOREIGN KEY (UserId) REFERENCES Users(Id),
    INDEX IX_Characters_UserId (UserId),
    INDEX IX_Characters_Name (Name)
);

-- æˆ˜æ–—è®°å½•è¡¨
CREATE TABLE BattleHistory (
    Id UNIQUEIDENTIFIER PRIMARY KEY DEFAULT NEWID(),
    CharacterId UNIQUEIDENTIFIER NOT NULL,
    EnemyId NVARCHAR(50) NOT NULL,
    StartTime DATETIME2 NOT NULL,
    EndTime DATETIME2,
    Result NVARCHAR(20), -- Victory, Defeat, Flee
    ExperienceGained INT DEFAULT 0,
    GoldGained INT DEFAULT 0,
    ItemsLooted NVARCHAR(MAX), -- JSONæ ¼å¼
    FOREIGN KEY (CharacterId) REFERENCES Characters(Id),
    INDEX IX_BattleHistory_CharacterId (CharacterId),
    INDEX IX_BattleHistory_StartTime (StartTime)
);
```

### 2. ç¼“å­˜ç­–ç•¥ä¼˜åŒ–

#### ğŸ¯ å½“å‰é—®é¢˜
- ç¼ºä¹ç³»ç»Ÿæ€§çš„ç¼“å­˜ç­–ç•¥
- é‡å¤æŸ¥è¯¢é€ æˆæ€§èƒ½æµªè´¹
- ç¼“å­˜å¤±æ•ˆç­–ç•¥ä¸å®Œå–„

#### ğŸ’¡ ä¼˜åŒ–æ–¹æ¡ˆ

**2.1 å¤šçº§ç¼“å­˜æ¶æ„**
```csharp
public class CacheService
{
    private readonly IMemoryCache _l1Cache;      // ä¸€çº§ç¼“å­˜ï¼ˆå†…å­˜ï¼‰
    private readonly IDistributedCache _l2Cache; // äºŒçº§ç¼“å­˜ï¼ˆRedisï¼‰
    private readonly ILogger<CacheService> _logger;

    public async Task<T?> GetAsync<T>(string key, Func<Task<T>> factory, TimeSpan? expiry = null)
    {
        // L1ç¼“å­˜æŸ¥è¯¢
        if (_l1Cache.TryGetValue(key, out T? cachedValue))
        {
            return cachedValue;
        }

        // L2ç¼“å­˜æŸ¥è¯¢
        var distributedValue = await _l2Cache.GetStringAsync(key);
        if (!string.IsNullOrEmpty(distributedValue))
        {
            var value = JsonSerializer.Deserialize<T>(distributedValue);
            _l1Cache.Set(key, value, TimeSpan.FromMinutes(5)); // L1ç¼“å­˜è¾ƒçŸ­æ—¶é—´
            return value;
        }

        // ç¼“å­˜æœªå‘½ä¸­ï¼Œä»æ•°æ®æºè·å–
        var result = await factory();
        if (result != null)
        {
            await SetAsync(key, result, expiry);
        }
        return result;
    }
}
```

**2.2 æ™ºèƒ½ç¼“å­˜ç­–ç•¥**
```csharp
public class SmartCacheStrategy
{
    // è§’è‰²æ•°æ®ç¼“å­˜ï¼ˆé«˜é¢‘è®¿é—®ï¼Œè¾ƒé•¿è¿‡æœŸæ—¶é—´ï¼‰
    public static CacheOptions CharacterCache => new()
    {
        L1Expiry = TimeSpan.FromMinutes(10),
        L2Expiry = TimeSpan.FromHours(1),
        RefreshThreshold = 0.8 // 80%æ—¶é—´ååˆ·æ–°
    };

    // æˆ˜æ–—çŠ¶æ€ç¼“å­˜ï¼ˆå®æ—¶æ€§è¦æ±‚é«˜ï¼Œè¾ƒçŸ­è¿‡æœŸæ—¶é—´ï¼‰
    public static CacheOptions BattleStateCache => new()
    {
        L1Expiry = TimeSpan.FromSeconds(30),
        L2Expiry = TimeSpan.FromMinutes(5),
        RefreshThreshold = 0.5
    };

    // é™æ€æ•°æ®ç¼“å­˜ï¼ˆå¾ˆå°‘å˜åŒ–ï¼Œé•¿æ—¶é—´ç¼“å­˜ï¼‰
    public static CacheOptions StaticDataCache => new()
    {
        L1Expiry = TimeSpan.FromHours(2),
        L2Expiry = TimeSpan.FromDays(1),
        RefreshThreshold = 0.9
    };
}
```

**2.3 ç¼“å­˜é¢„çƒ­å’Œå¤±æ•ˆ**
```csharp
public class CacheWarmupService : IHostedService
{
    public async Task StartAsync(CancellationToken cancellationToken)
    {
        // é¢„çƒ­å¸¸ç”¨æ•°æ®
        await WarmupStaticData();
        await WarmupActiveCharacters();
    }

    private async Task WarmupStaticData()
    {
        // é¢„åŠ è½½ç‰©å“æ•°æ®ã€æŠ€èƒ½æ•°æ®ç­‰
        var items = await _itemService.GetAllItemsAsync();
        await _cacheService.SetAsync("all_items", items, TimeSpan.FromDays(1));
    }
}

public class CacheInvalidationService
{
    public async Task InvalidateCharacterCache(string characterId)
    {
        var keys = new[]
        {
            $"character:{characterId}",
            $"character_stats:{characterId}",
            $"character_equipment:{characterId}"
        };
        
        await Task.WhenAll(keys.Select(key => _cache.RemoveAsync(key)));
    }
}
```

### 3. å¹¶å‘æ§åˆ¶ä¼˜åŒ–

#### ğŸ¯ å½“å‰é—®é¢˜
- é«˜å¹¶å‘åœºæ™¯ä¸‹å¯èƒ½å‡ºç°æ•°æ®ç«äº‰
- ç¼ºä¹åˆ†å¸ƒå¼é”æœºåˆ¶
- æˆ˜æ–—çŠ¶æ€æ›´æ–°å¯èƒ½ä¸ä¸€è‡´

#### ğŸ’¡ ä¼˜åŒ–æ–¹æ¡ˆ

**3.1 åˆ†å¸ƒå¼é”å®ç°**
```csharp
public interface IDistributedLock
{
    Task<IDisposable?> AcquireAsync(string key, TimeSpan expiry, TimeSpan timeout);
}

public class RedisDistributedLock : IDistributedLock
{
    private readonly IDatabase _database;
    
    public async Task<IDisposable?> AcquireAsync(string key, TimeSpan expiry, TimeSpan timeout)
    {
        var lockKey = $"lock:{key}";
        var lockValue = Guid.NewGuid().ToString();
        var endTime = DateTime.UtcNow.Add(timeout);

        while (DateTime.UtcNow < endTime)
        {
            if (await _database.StringSetAsync(lockKey, lockValue, expiry, When.NotExists))
            {
                return new LockToken(_database, lockKey, lockValue);
            }
            await Task.Delay(50); // ç­‰å¾…50msåé‡è¯•
        }
        return null; // è·å–é”è¶…æ—¶
    }
}

// ä½¿ç”¨ç¤ºä¾‹
public async Task<bool> UpdateBattleStateAsync(Guid battleId, BattleStateDto newState)
{
    using var lockToken = await _distributedLock.AcquireAsync(
        $"battle:{battleId}", 
        TimeSpan.FromSeconds(30), 
        TimeSpan.FromSeconds(5));
    
    if (lockToken == null)
    {
        _logger.LogWarning("Failed to acquire lock for battle {BattleId}", battleId);
        return false;
    }

    // å®‰å…¨åœ°æ›´æ–°æˆ˜æ–—çŠ¶æ€
    await _battleRepository.UpdateAsync(battleId, newState);
    await _cache.InvalidateAsync($"battle_state:{battleId}");
    
    return true;
}
```

**3.2 ä¹è§‚å¹¶å‘æ§åˆ¶**
```csharp
public class Character
{
    public string Id { get; set; }
    public string Name { get; set; }
    public int Level { get; set; }
    public long Experience { get; set; }
    
    [ConcurrencyCheck] // ä¹è§‚å¹¶å‘æ§åˆ¶
    public byte[] RowVersion { get; set; }
}

public async Task<bool> UpdateCharacterAsync(Character character)
{
    try
    {
        _context.Entry(character).State = EntityState.Modified;
        await _context.SaveChangesAsync();
        return true;
    }
    catch (DbUpdateConcurrencyException ex)
    {
        _logger.LogWarning("Concurrency conflict updating character {CharacterId}", character.Id);
        
        // å¤„ç†å¹¶å‘å†²çªï¼Œå¯ä»¥é€‰æ‹©é‡è¯•æˆ–è€…åˆå¹¶æ›´æ”¹
        return await HandleConcurrencyConflict(character, ex);
    }
}
```

**3.3 äº‹ä»¶æ’åºå’Œæ‰¹å¤„ç†**
```csharp
public class OrderedEventProcessor
{
    private readonly ConcurrentDictionary<string, SemaphoreSlim> _entitySemaphores = new();
    
    public async Task ProcessEventAsync(GameEvent gameEvent)
    {
        var entityId = gameEvent.EntityId;
        var semaphore = _entitySemaphores.GetOrAdd(entityId, _ => new SemaphoreSlim(1, 1));
        
        await semaphore.WaitAsync();
        try
        {
            // ä¸²è¡Œå¤„ç†åŒä¸€å®ä½“çš„äº‹ä»¶ï¼Œç¡®ä¿é¡ºåºæ€§
            await ProcessSingleEventAsync(gameEvent);
        }
        finally
        {
            semaphore.Release();
        }
    }
}

public class BatchEventProcessor
{
    private readonly Timer _timer;
    private readonly ConcurrentQueue<GameEvent> _eventQueue = new();
    
    public void EnqueueEvent(GameEvent gameEvent)
    {
        _eventQueue.Enqueue(gameEvent);
    }
    
    private async Task ProcessBatch()
    {
        var events = new List<GameEvent>();
        
        // æ‰¹é‡è·å–äº‹ä»¶
        while (_eventQueue.TryDequeue(out var evt) && events.Count < 100)
        {
            events.Add(evt);
        }
        
        if (events.Count > 0)
        {
            await ProcessEventsInBatch(events);
        }
    }
}
```

### 4. æ€§èƒ½ä¼˜åŒ–

#### ğŸ¯ å½“å‰é—®é¢˜
- éƒ¨åˆ†å¼‚æ­¥æ–¹æ³•ç¼ºå°‘awaitæ“ä½œç¬¦
- åŒæ­¥æ“ä½œé˜»å¡çº¿ç¨‹æ± 
- å†…å­˜ä½¿ç”¨æ•ˆç‡æœ‰å¾…æå‡

#### ğŸ’¡ ä¼˜åŒ–æ–¹æ¡ˆ

**4.1 å¼‚æ­¥æ“ä½œä¼˜åŒ–**
```csharp
// ä¿®å¤å¼‚æ­¥æ–¹æ³•è­¦å‘Š
public async Task<List<ItemDto>> GetInventoryItemsAsync(string characterId)
{
    var character = await _characterService.GetCharacterAsync(characterId);
    if (character == null) return new List<ItemDto>();
    
    // å¹¶è¡Œè·å–ç‰©å“è¯¦æƒ…
    var itemTasks = character.InventoryItemIds.Select(async itemId =>
    {
        var item = await _itemService.GetItemAsync(itemId);
        return item?.ToDto();
    });
    
    var items = await Task.WhenAll(itemTasks);
    return items.Where(item => item != null).ToList()!;
}

// ä½¿ç”¨ValueTaskä¼˜åŒ–é«˜é¢‘è°ƒç”¨
public ValueTask<BattleStateDto?> GetBattleStateAsync(Guid battleId)
{
    // å…ˆæ£€æŸ¥ç¼“å­˜
    if (_memoryCache.TryGetValue($"battle:{battleId}", out BattleStateDto? cached))
    {
        return ValueTask.FromResult(cached);
    }
    
    // ç¼“å­˜æœªå‘½ä¸­ï¼Œå¼‚æ­¥åŠ è½½
    return new ValueTask<BattleStateDto?>(LoadBattleStateAsync(battleId));
}
```

**4.2 å†…å­˜ä½¿ç”¨ä¼˜åŒ–**
```csharp
// ä½¿ç”¨å¯¹è±¡æ± å‡å°‘GCå‹åŠ›
public class BattleStatePool : ObjectPool<BattleStateDto>
{
    public override BattleStateDto Get()
    {
        var item = base.Get();
        // é‡ç½®å¯¹è±¡çŠ¶æ€
        item.Reset();
        return item;
    }
}

// ä½¿ç”¨Span<T>å’ŒMemory<T>å‡å°‘å†…å­˜åˆ†é…
public void ProcessBattleData(ReadOnlySpan<byte> data)
{
    // é¿å…ä¸å¿…è¦çš„å†…å­˜åˆ†é…
    var battleId = new Guid(data.Slice(0, 16));
    var health = BitConverter.ToInt32(data.Slice(16, 4));
    // ...
}

// ä½¿ç”¨StringPoolå‡å°‘å­—ç¬¦ä¸²åˆ†é…
public class StringPool
{
    private static readonly ConcurrentDictionary<string, string> _pool = new();
    
    public static string Intern(string value)
    {
        return _pool.GetOrAdd(value, value);
    }
}
```

**4.3 æ•°æ®åº“æŸ¥è¯¢ä¼˜åŒ–**
```csharp
// ä½¿ç”¨æŠ•å½±å‡å°‘æ•°æ®ä¼ è¾“
public async Task<List<CharacterSummaryDto>> GetCharacterSummariesAsync(string userId)
{
    return await _context.Characters
        .Where(c => c.UserId == userId)
        .Select(c => new CharacterSummaryDto
        {
            Id = c.Id,
            Name = c.Name,
            Level = c.Level,
            Class = c.Class
        })
        .ToListAsync();
}

// ä½¿ç”¨é¢„ç¼–è¯‘æŸ¥è¯¢æå‡æ€§èƒ½
private static readonly Func<GameDbContext, string, Task<Character?>> GetCharacterByIdQuery =
    EF.CompileAsyncQuery((GameDbContext context, string id) =>
        context.Characters.FirstOrDefault(c => c.Id == id));

public async Task<Character?> GetCharacterAsync(string id)
{
    return await GetCharacterByIdQuery(_context, id);
}

// æ‰¹é‡æ“ä½œä¼˜åŒ–
public async Task UpdateMultipleCharactersAsync(List<Character> characters)
{
    _context.Characters.UpdateRange(characters);
    await _context.SaveChangesAsync();
}
```

### 5. æ¶æ„ä¼˜åŒ–

#### ğŸ¯ å½“å‰é—®é¢˜
- æœåŠ¡é—´è€¦åˆåº¦è¾ƒé«˜
- ç¼ºä¹æ¸…æ™°çš„é¢†åŸŸè¾¹ç•Œ
- äº‹åŠ¡ç®¡ç†ä¸å¤Ÿå®Œå–„

#### ğŸ’¡ ä¼˜åŒ–æ–¹æ¡ˆ

**5.1 é¢†åŸŸé©±åŠ¨è®¾è®¡(DDD)é‡æ„**
```csharp
// å®šä¹‰èšåˆæ ¹
public class CharacterAggregate : AggregateRoot
{
    public string Id { get; private set; }
    public string Name { get; private set; }
    public CharacterStats Stats { get; private set; }
    public Inventory Inventory { get; private set; }
    
    // å°è£…ä¸šåŠ¡é€»è¾‘
    public void LevelUp(int experienceGained)
    {
        if (experienceGained <= 0)
            throw new ArgumentException("Experience must be positive");
            
        Stats.AddExperience(experienceGained);
        
        if (Stats.CanLevelUp())
        {
            var oldLevel = Stats.Level;
            Stats.LevelUp();
            
            // å‘å¸ƒé¢†åŸŸäº‹ä»¶
            RaiseDomainEvent(new CharacterLeveledUpEvent(Id, oldLevel, Stats.Level));
        }
    }
}

// é¢†åŸŸæœåŠ¡
public class BattleService : IDomainService
{
    public BattleResult ProcessBattle(CharacterAggregate attacker, EnemyAggregate defender)
    {
        // å¤æ‚çš„æˆ˜æ–—é€»è¾‘
        var damage = CalculateDamage(attacker.Stats, defender.Stats);
        defender.TakeDamage(damage);
        
        if (defender.IsDead())
        {
            var experience = CalculateExperience(defender.Level);
            attacker.LevelUp(experience);
            
            return BattleResult.Victory(experience);
        }
        
        return BattleResult.Ongoing();
    }
}
```

**5.2 CQRSæ¨¡å¼å®ç°**
```csharp
// å‘½ä»¤å’ŒæŸ¥è¯¢åˆ†ç¦»
public interface ICommand { }
public interface IQuery<TResult> { }
public interface ICommandHandler<TCommand> where TCommand : ICommand
{
    Task HandleAsync(TCommand command);
}
public interface IQueryHandler<TQuery, TResult> where TQuery : IQuery<TResult>
{
    Task<TResult> HandleAsync(TQuery query);
}

// å‘½ä»¤ç¤ºä¾‹
public class CreateCharacterCommand : ICommand
{
    public string UserId { get; set; }
    public string Name { get; set; }
    public CharacterClass Class { get; set; }
}

public class CreateCharacterCommandHandler : ICommandHandler<CreateCharacterCommand>
{
    public async Task HandleAsync(CreateCharacterCommand command)
    {
        // åˆ›å»ºè§’è‰²çš„ä¸šåŠ¡é€»è¾‘
        var character = new CharacterAggregate(command.UserId, command.Name, command.Class);
        await _repository.SaveAsync(character);
        
        // å‘å¸ƒäº‹ä»¶
        await _eventBus.PublishAsync(new CharacterCreatedEvent(character.Id));
    }
}

// æŸ¥è¯¢ç¤ºä¾‹
public class GetCharacterQuery : IQuery<CharacterDto>
{
    public string CharacterId { get; set; }
}

public class GetCharacterQueryHandler : IQueryHandler<GetCharacterQuery, CharacterDto>
{
    public async Task<CharacterDto> HandleAsync(GetCharacterQuery query)
    {
        // ä»åªè¯»æ•°æ®æºæŸ¥è¯¢
        return await _readOnlyRepository.GetCharacterAsync(query.CharacterId);
    }
}
```

**5.3 äº‹ä»¶é©±åŠ¨æ¶æ„å®Œå–„**
```csharp
// äº‹ä»¶æ€»çº¿
public interface IEventBus
{
    Task PublishAsync<T>(T @event) where T : IDomainEvent;
    void Subscribe<T>(Func<T, Task> handler) where T : IDomainEvent;
}

public class InMemoryEventBus : IEventBus
{
    private readonly ConcurrentDictionary<Type, List<Func<object, Task>>> _handlers = new();
    
    public async Task PublishAsync<T>(T @event) where T : IDomainEvent
    {
        if (_handlers.TryGetValue(typeof(T), out var handlers))
        {
            var tasks = handlers.Select(handler => handler(@event));
            await Task.WhenAll(tasks);
        }
    }
}

// äº‹ä»¶å¤„ç†å™¨
public class CharacterLeveledUpEventHandler : IEventHandler<CharacterLeveledUpEvent>
{
    public async Task HandleAsync(CharacterLeveledUpEvent @event)
    {
        // æ›´æ–°ç»Ÿè®¡æ•°æ®
        await _statisticsService.RecordLevelUpAsync(@event.CharacterId);
        
        // å‘é€é€šçŸ¥
        await _notificationService.NotifyLevelUpAsync(@event.CharacterId, @event.NewLevel);
        
        // æ›´æ–°æ’è¡Œæ¦œ
        await _leaderboardService.UpdateAsync(@event.CharacterId);
    }
}
```

### 6. å®‰å…¨æ€§ä¼˜åŒ–

#### ğŸ¯ å½“å‰é—®é¢˜
- JWTå¯†é’¥ç®¡ç†éœ€è¦å¢å¼º
- è¾“å…¥éªŒè¯éœ€è¦åŠ å¼º
- å®¡è®¡æ—¥å¿—ä¸å¤Ÿå®Œå–„

#### ğŸ’¡ ä¼˜åŒ–æ–¹æ¡ˆ

**6.1 å¢å¼ºè®¤è¯å®‰å…¨**
```csharp
// ä½¿ç”¨éå¯¹ç§°åŠ å¯†
public class EnhancedJwtService
{
    private readonly RSA _rsa;
    
    public string GenerateToken(User user)
    {
        var tokenHandler = new JwtSecurityTokenHandler();
        var key = new RsaSecurityKey(_rsa);
        
        var tokenDescriptor = new SecurityTokenDescriptor
        {
            Subject = new ClaimsIdentity(new[]
            {
                new Claim("sub", user.Id),
                new Claim("username", user.Username),
                new Claim("role", user.Role),
                new Claim("jti", Guid.NewGuid().ToString()), // JWT IDé˜²é‡æ”¾
                new Claim("iat", DateTimeOffset.UtcNow.ToUnixTimeSeconds().ToString(), ClaimValueTypes.Integer64)
            }),
            Expires = DateTime.UtcNow.AddMinutes(_jwtOptions.ExpirationMinutes),
            Issuer = _jwtOptions.Issuer,
            Audience = _jwtOptions.Audience,
            SigningCredentials = new SigningCredentials(key, SecurityAlgorithms.RsaSha256)
        };
        
        var token = tokenHandler.CreateToken(tokenDescriptor);
        return tokenHandler.WriteToken(token);
    }
}

// ä»¤ç‰Œé»‘åå•
public class TokenBlacklistService
{
    private readonly IDistributedCache _cache;
    
    public async Task BlacklistTokenAsync(string jti, TimeSpan expiry)
    {
        await _cache.SetStringAsync($"blacklist:{jti}", "true", new DistributedCacheEntryOptions
        {
            AbsoluteExpirationRelativeToNow = expiry
        });
    }
    
    public async Task<bool> IsTokenBlacklistedAsync(string jti)
    {
        var result = await _cache.GetStringAsync($"blacklist:{jti}");
        return !string.IsNullOrEmpty(result);
    }
}
```

**6.2 è¾“å…¥éªŒè¯å¢å¼º**
```csharp
// è‡ªå®šä¹‰éªŒè¯å±æ€§
public class ValidCharacterNameAttribute : ValidationAttribute
{
    public override bool IsValid(object? value)
    {
        if (value is not string name) return false;
        
        // æ£€æŸ¥é•¿åº¦
        if (name.Length < 3 || name.Length > 20) return false;
        
        // æ£€æŸ¥å­—ç¬¦
        if (!Regex.IsMatch(name, @"^[a-zA-Z0-9_]+$")) return false;
        
        // æ£€æŸ¥æ•æ„Ÿè¯
        if (ContainsProfanity(name)) return false;
        
        return true;
    }
}

// DTOéªŒè¯
public class CreateCharacterRequest
{
    [Required]
    [ValidCharacterName]
    public string Name { get; set; } = string.Empty;
    
    [Required]
    [EnumDataType(typeof(CharacterClass))]
    public CharacterClass Class { get; set; }
    
    [Range(1, 100)]
    public int StartingLevel { get; set; } = 1;
}

// æœåŠ¡å™¨ç«¯éªŒè¯
public async Task<ValidationResult> ValidateCreateCharacterAsync(CreateCharacterRequest request)
{
    var result = new ValidationResult();
    
    // æ£€æŸ¥è§’è‰²åé‡å¤
    if (await _characterRepository.ExistsAsync(request.Name))
    {
        result.AddError("Name", "Character name already exists");
    }
    
    // æ£€æŸ¥ç”¨æˆ·è§’è‰²æ•°é‡é™åˆ¶
    var userCharacterCount = await _characterRepository.CountByUserAsync(GetCurrentUserId());
    if (userCharacterCount >= 5)
    {
        result.AddError("", "Maximum character limit reached");
    }
    
    return result;
}
```

**6.3 å®¡è®¡æ—¥å¿—ç³»ç»Ÿ**
```csharp
public class AuditLogService
{
    public async Task LogUserActionAsync(string userId, string action, object? data = null)
    {
        var auditLog = new AuditLog
        {
            UserId = userId,
            Action = action,
            Data = data != null ? JsonSerializer.Serialize(data) : null,
            Timestamp = DateTime.UtcNow,
            IpAddress = GetClientIpAddress(),
            UserAgent = GetUserAgent()
        };
        
        await _auditRepository.CreateAsync(auditLog);
    }
    
    public async Task LogSecurityEventAsync(string userId, SecurityEventType eventType, string details)
    {
        var securityLog = new SecurityLog
        {
            UserId = userId,
            EventType = eventType,
            Details = details,
            Timestamp = DateTime.UtcNow,
            IpAddress = GetClientIpAddress(),
            Severity = GetSeverityLevel(eventType)
        };
        
        await _securityLogRepository.CreateAsync(securityLog);
        
        // é«˜é£é™©äº‹ä»¶å®æ—¶å‘Šè­¦
        if (securityLog.Severity >= SecuritySeverity.High)
        {
            await _alertService.SendSecurityAlertAsync(securityLog);
        }
    }
}

// ä½¿ç”¨æ‹¦æˆªå™¨è‡ªåŠ¨è®°å½•å®¡è®¡æ—¥å¿—
public class AuditInterceptor : IInterceptor
{
    public void Intercept(IInvocation invocation)
    {
        var stopwatch = Stopwatch.StartNew();
        
        try
        {
            invocation.Proceed();
            
            // è®°å½•æˆåŠŸæ“ä½œ
            _ = Task.Run(() => LogSuccessfulOperation(invocation, stopwatch.Elapsed));
        }
        catch (Exception ex)
        {
            // è®°å½•å¤±è´¥æ“ä½œ
            _ = Task.Run(() => LogFailedOperation(invocation, ex, stopwatch.Elapsed));
            throw;
        }
    }
}
```

### 7. ç›‘æ§å’Œè¿ç»´ä¼˜åŒ–

#### ğŸ¯ å½“å‰é—®é¢˜
- ç›‘æ§æŒ‡æ ‡ä¸å¤Ÿå…¨é¢
- ç¼ºä¹è‡ªåŠ¨åŒ–è¿ç»´å·¥å…·
- å‘Šè­¦æœºåˆ¶å¾…å®Œå–„

#### ğŸ’¡ ä¼˜åŒ–æ–¹æ¡ˆ

**7.1 å…¨é¢ç›‘æ§ä½“ç³»**
```csharp
// è‡ªå®šä¹‰æŒ‡æ ‡æ”¶é›†
public class MetricsCollector
{
    private readonly IMetrics _metrics;
    
    public void RecordBattleStarted(string characterClass)
    {
        _metrics.Measure.Counter.Increment("battles_started_total", 
            new MetricTags("character_class", characterClass));
    }
    
    public void RecordApiResponseTime(string endpoint, double responseTimeMs)
    {
        _metrics.Measure.Histogram.Update("api_response_time_ms", responseTimeMs,
            new MetricTags("endpoint", endpoint));
    }
    
    public void RecordActiveUsers(int count)
    {
        _metrics.Measure.Gauge.SetValue("active_users_current", count);
    }
}

// å¥åº·æ£€æŸ¥å¢å¼º
public class ComprehensiveHealthCheck : IHealthCheck
{
    public async Task<HealthCheckResult> CheckHealthAsync(HealthCheckContext context, 
        CancellationToken cancellationToken = default)
    {
        var checks = new Dictionary<string, object>();
        var overallStatus = HealthStatus.Healthy;
        
        // æ•°æ®åº“è¿æ¥æ£€æŸ¥
        try
        {
            await _dbContext.Database.ExecuteSqlRawAsync("SELECT 1", cancellationToken);
            checks["database"] = "Connected";
        }
        catch (Exception ex)
        {
            checks["database"] = $"Error: {ex.Message}";
            overallStatus = HealthStatus.Unhealthy;
        }
        
        // Redisè¿æ¥æ£€æŸ¥
        try
        {
            await _distributedCache.SetStringAsync("health_check", "ok", cancellationToken);
            checks["redis"] = "Connected";
        }
        catch (Exception ex)
        {
            checks["redis"] = $"Error: {ex.Message}";
            overallStatus = HealthStatus.Degraded;
        }
        
        // å†…å­˜ä½¿ç”¨æ£€æŸ¥
        var memoryUsage = GC.GetTotalMemory(false);
        checks["memory_usage_mb"] = memoryUsage / 1024 / 1024;
        
        if (memoryUsage > 1000 * 1024 * 1024) // 1GB
        {
            overallStatus = HealthStatus.Degraded;
        }
        
        // æ´»è·ƒè¿æ¥æ£€æŸ¥
        var activeConnections = _connectionTracker.GetActiveConnectionCount();
        checks["active_connections"] = activeConnections;
        
        return new HealthCheckResult(overallStatus, "System health check", null, checks);
    }
}
```

**7.2 è‡ªåŠ¨åŒ–éƒ¨ç½²å’Œæ‰©å®¹**
```yaml
# Kubernetes Deployment
apiVersion: apps/v1
kind: Deployment
metadata:
  name: blazorwebgame-server
spec:
  replicas: 3
  selector:
    matchLabels:
      app: blazorwebgame-server
  template:
    metadata:
      labels:
        app: blazorwebgame-server
    spec:
      containers:
      - name: server
        image: blazorwebgame/server:latest
        ports:
        - containerPort: 80
        env:
        - name: ASPNETCORE_ENVIRONMENT
          value: "Production"
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health/simple
            port: 80
          initialDelaySeconds: 30
          periodSeconds: 30
        readinessProbe:
          httpGet:
            path: /health
            port: 80
          initialDelaySeconds: 5
          periodSeconds: 10

---
# Horizontal Pod Autoscaler
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: blazorwebgame-server-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: blazorwebgame-server
  minReplicas: 3
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
```

**7.3 æ™ºèƒ½å‘Šè­¦ç³»ç»Ÿ**
```csharp
public class AlertingService
{
    private readonly Dictionary<AlertType, AlertRule> _alertRules = new()
    {
        [AlertType.HighErrorRate] = new AlertRule
        {
            Threshold = 0.05, // 5% é”™è¯¯ç‡
            WindowMinutes = 5,
            MinSamples = 100,
            Severity = AlertSeverity.Critical
        },
        [AlertType.HighMemoryUsage] = new AlertRule
        {
            Threshold = 0.8, // 80% å†…å­˜ä½¿ç”¨ç‡
            WindowMinutes = 10,
            MinSamples = 5,
            Severity = AlertSeverity.Warning
        },
        [AlertType.SlowResponse] = new AlertRule
        {
            Threshold = 2000, // 2ç§’å“åº”æ—¶é—´
            WindowMinutes = 5,
            MinSamples = 50,
            Severity = AlertSeverity.Warning
        }
    };
    
    public async Task EvaluateAlertsAsync()
    {
        foreach (var rule in _alertRules)
        {
            var shouldAlert = await EvaluateRuleAsync(rule.Key, rule.Value);
            if (shouldAlert)
            {
                await SendAlertAsync(rule.Key, rule.Value);
            }
        }
    }
    
    private async Task SendAlertAsync(AlertType alertType, AlertRule rule)
    {
        var alert = new Alert
        {
            Type = alertType,
            Severity = rule.Severity,
            Message = GenerateAlertMessage(alertType),
            Timestamp = DateTime.UtcNow,
            Resolved = false
        };
        
        // å‘é€åˆ°å¤šä¸ªæ¸ é“
        await Task.WhenAll(
            _emailService.SendAlertAsync(alert),
            _slackService.SendAlertAsync(alert),
            _webhookService.SendAlertAsync(alert)
        );
        
        await _alertRepository.SaveAsync(alert);
    }
}
```

### 8. æµ‹è¯•ä¼˜åŒ–

#### ğŸ¯ å½“å‰é—®é¢˜
- ç¼ºä¹å®Œæ•´çš„æµ‹è¯•è¦†ç›–
- é›†æˆæµ‹è¯•ä¸è¶³
- æ€§èƒ½æµ‹è¯•ç¼ºå¤±

#### ğŸ’¡ ä¼˜åŒ–æ–¹æ¡ˆ

**8.1 å•å…ƒæµ‹è¯•å®Œå–„**
```csharp
[TestFixture]
public class BattleServiceTests
{
    private Mock<ICharacterRepository> _characterRepositoryMock;
    private Mock<ILogger<BattleService>> _loggerMock;
    private BattleService _battleService;
    
    [SetUp]
    public void Setup()
    {
        _characterRepositoryMock = new Mock<ICharacterRepository>();
        _loggerMock = new Mock<ILogger<BattleService>>();
        _battleService = new BattleService(_characterRepositoryMock.Object, _loggerMock.Object);
    }
    
    [Test]
    public async Task StartBattle_ValidRequest_ReturnsBattleState()
    {
        // Arrange
        var character = new Character { Id = "char1", Health = 100 };
        _characterRepositoryMock.Setup(r => r.GetAsync("char1"))
            .ReturnsAsync(character);
        
        var request = new StartBattleRequest
        {
            CharacterId = "char1",
            EnemyId = "goblin"
        };
        
        // Act
        var result = await _battleService.StartBattleAsync(request);
        
        // Assert
        Assert.That(result, Is.Not.Null);
        Assert.That(result.CharacterId, Is.EqualTo("char1"));
        Assert.That(result.IsActive, Is.True);
    }
    
    [Test]
    public async Task StartBattle_CharacterNotFound_ThrowsNotFoundException()
    {
        // Arrange
        _characterRepositoryMock.Setup(r => r.GetAsync("char1"))
            .ReturnsAsync((Character?)null);
        
        var request = new StartBattleRequest
        {
            CharacterId = "char1",
            EnemyId = "goblin"
        };
        
        // Act & Assert
        Assert.ThrowsAsync<NotFoundException>(() => _battleService.StartBattleAsync(request));
    }
}
```

**8.2 é›†æˆæµ‹è¯•**
```csharp
[TestFixture]
public class BattleControllerIntegrationTests
{
    private WebApplicationFactory<Program> _factory;
    private HttpClient _client;
    private string _authToken;
    
    [OneTimeSetUp]
    public async Task OneTimeSetUp()
    {
        _factory = new WebApplicationFactory<Program>()
            .WithWebHostBuilder(builder =>
            {
                builder.ConfigureServices(services =>
                {
                    // æ›¿æ¢ä¸ºæµ‹è¯•æ•°æ®åº“
                    services.RemoveAll<DbContextOptions<GameDbContext>>();
                    services.AddDbContext<GameDbContext>(options =>
                        options.UseInMemoryDatabase("TestDb"));
                });
            });
        
        _client = _factory.CreateClient();
        _authToken = await GetAuthTokenAsync();
    }
    
    [Test]
    public async Task StartBattle_ValidRequest_ReturnsOk()
    {
        // Arrange
        var request = new StartBattleRequest
        {
            CharacterId = "test-character",
            EnemyId = "goblin"
        };
        
        _client.DefaultRequestHeaders.Authorization = 
            new AuthenticationHeaderValue("Bearer", _authToken);
        
        // Act
        var response = await _client.PostAsJsonAsync("/api/battle/start", request);
        
        // Assert
        Assert.That(response.StatusCode, Is.EqualTo(HttpStatusCode.OK));
        
        var content = await response.Content.ReadFromJsonAsync<ApiResponse<BattleStateDto>>();
        Assert.That(content.Success, Is.True);
        Assert.That(content.Data, Is.Not.Null);
    }
}
```

**8.3 æ€§èƒ½æµ‹è¯•**
```csharp
[Test]
public async Task BattleSystem_LoadTest_HandlesHighConcurrency()
{
    const int concurrentUsers = 100;
    const int battlesPerUser = 10;
    
    var tasks = new List<Task>();
    var successCount = 0;
    var errorCount = 0;
    
    for (int i = 0; i < concurrentUsers; i++)
    {
        var userId = $"user_{i}";
        tasks.Add(Task.Run(async () =>
        {
            for (int j = 0; j < battlesPerUser; j++)
            {
                try
                {
                    var result = await _battleService.StartBattleAsync(new StartBattleRequest
                    {
                        CharacterId = $"{userId}_char",
                        EnemyId = "goblin"
                    });
                    
                    Interlocked.Increment(ref successCount);
                }
                catch
                {
                    Interlocked.Increment(ref errorCount);
                }
            }
        }));
    }
    
    var stopwatch = Stopwatch.StartNew();
    await Task.WhenAll(tasks);
    stopwatch.Stop();
    
    Console.WriteLine($"Total time: {stopwatch.ElapsedMilliseconds}ms");
    Console.WriteLine($"Successful battles: {successCount}");
    Console.WriteLine($"Failed battles: {errorCount}");
    Console.WriteLine($"Throughput: {successCount / stopwatch.Elapsed.TotalSeconds:F2} battles/sec");
    
    // æ–­è¨€æ€§èƒ½è¦æ±‚
    Assert.That(stopwatch.ElapsedMilliseconds, Is.LessThan(30000), "Test should complete within 30 seconds");
    Assert.That(errorCount, Is.LessThan(successCount * 0.01), "Error rate should be less than 1%");
}
```

## ğŸ“… å®æ–½è®¡åˆ’

### ç¬¬ä¸€é˜¶æ®µï¼ˆ1-2å‘¨ï¼‰ï¼šåŸºç¡€ä¼˜åŒ–
- [ ] ä¿®å¤å¼‚æ­¥æ–¹æ³•è­¦å‘Š
- [ ] å®ç°åŸºç¡€ç¼“å­˜ç­–ç•¥
- [ ] å®Œå–„é”™è¯¯å¤„ç†æœºåˆ¶
- [ ] å¢å¼ºè¾“å…¥éªŒè¯

### ç¬¬äºŒé˜¶æ®µï¼ˆ2-3å‘¨ï¼‰ï¼šå­˜å‚¨ä¼˜åŒ–
- [ ] å¼•å…¥æ•°æ®åº“æ”¯æŒ
- [ ] å®ç°åˆ†å±‚å­˜å‚¨ç­–ç•¥
- [ ] å»ºç«‹æ•°æ®è¿ç§»æœºåˆ¶
- [ ] å®Œå–„æ•°æ®å¤‡ä»½æ–¹æ¡ˆ

### ç¬¬ä¸‰é˜¶æ®µï¼ˆ2-3å‘¨ï¼‰ï¼šæ€§èƒ½ä¼˜åŒ–
- [ ] å®ç°åˆ†å¸ƒå¼é”
- [ ] ä¼˜åŒ–æ•°æ®åº“æŸ¥è¯¢
- [ ] å®ç°å¯¹è±¡æ± å’Œå†…å­˜ä¼˜åŒ–
- [ ] å»ºç«‹æ€§èƒ½ç›‘æ§ä½“ç³»

### ç¬¬å››é˜¶æ®µï¼ˆ2-3å‘¨ï¼‰ï¼šæ¶æ„é‡æ„
- [ ] å®æ–½DDDæ¨¡å¼
- [ ] å¼•å…¥CQRSæ¶æ„
- [ ] å®Œå–„äº‹ä»¶é©±åŠ¨ç³»ç»Ÿ
- [ ] å»ºç«‹è‡ªåŠ¨åŒ–æµ‹è¯•

### ç¬¬äº”é˜¶æ®µï¼ˆ1-2å‘¨ï¼‰ï¼šå®‰å…¨å’Œè¿ç»´
- [ ] å¢å¼ºå®‰å…¨æœºåˆ¶
- [ ] å®Œå–„ç›‘æ§å‘Šè­¦
- [ ] å®ç°è‡ªåŠ¨åŒ–éƒ¨ç½²
- [ ] å»ºç«‹è¿ç»´æ–‡æ¡£

## ğŸ¯ é¢„æœŸæ”¶ç›Š

### æ€§èƒ½æå‡
- **å“åº”æ—¶é—´**: å¹³å‡å“åº”æ—¶é—´é™ä½50%
- **ååé‡**: æ”¯æŒå¹¶å‘ç”¨æˆ·æ•°æå‡3å€
- **å†…å­˜ä½¿ç”¨**: å†…å­˜ä½¿ç”¨æ•ˆç‡æå‡40%
- **é”™è¯¯ç‡**: ç³»ç»Ÿé”™è¯¯ç‡é™ä½åˆ°0.1%ä»¥ä¸‹

### å¯ç»´æŠ¤æ€§æå‡
- **ä»£ç è´¨é‡**: æµ‹è¯•è¦†ç›–ç‡è¾¾åˆ°80%ä»¥ä¸Š
- **æ¶æ„æ¸…æ™°**: æ¨¡å—é—´è€¦åˆåº¦é™ä½
- **æ–‡æ¡£å®Œå–„**: å®Œæ•´çš„APIå’Œæ¶æ„æ–‡æ¡£
- **å¼€å‘æ•ˆç‡**: æ–°åŠŸèƒ½å¼€å‘æ•ˆç‡æå‡30%

### è¿ç»´æ•ˆç‡æå‡
- **ç›‘æ§å®Œå–„**: å®æ—¶ç›‘æ§å’Œå‘Šè­¦ç³»ç»Ÿ
- **è‡ªåŠ¨åŒ–**: è‡ªåŠ¨åŒ–éƒ¨ç½²å’Œæ‰©å®¹
- **ç¨³å®šæ€§**: ç³»ç»Ÿå¯ç”¨æ€§è¾¾åˆ°99.9%
- **æ•…éšœæ¢å¤**: å¹³å‡æ•…éšœæ¢å¤æ—¶é—´å°äº5åˆ†é’Ÿ

## ğŸ“‹ æ€»ç»“

æœ¬ä¼˜åŒ–æ–¹æ¡ˆä»æ•°æ®å­˜å‚¨ã€ç¼“å­˜ç­–ç•¥ã€å¹¶å‘æ§åˆ¶ã€æ€§èƒ½ä¼˜åŒ–ã€æ¶æ„é‡æ„ã€å®‰å…¨å¢å¼ºã€ç›‘æ§è¿ç»´ã€æµ‹è¯•å®Œå–„ç­‰8ä¸ªç»´åº¦æå‡ºäº†å…¨é¢çš„ä¼˜åŒ–å»ºè®®ã€‚

**å…³é”®ä¼˜åŒ–ç‚¹**ï¼š
1. **æ•°æ®æŒä¹…åŒ–**: ä»å†…å­˜å­˜å‚¨è¿ç§»åˆ°æ•°æ®åº“+ç¼“å­˜çš„æ··åˆæ¶æ„
2. **æ€§èƒ½ä¼˜åŒ–**: è§£å†³å¼‚æ­¥ç¼–ç¨‹é—®é¢˜ï¼Œæå‡ç³»ç»Ÿå“åº”é€Ÿåº¦
3. **æ¶æ„å‡çº§**: å¼•å…¥DDDå’ŒCQRSæ¨¡å¼ï¼Œæå‡ä»£ç è´¨é‡å’Œå¯ç»´æŠ¤æ€§
4. **å®‰å…¨åŠ å›º**: å¢å¼ºè®¤è¯æœºåˆ¶å’Œå®¡è®¡æ—¥å¿—ç³»ç»Ÿ
5. **è¿ç»´è‡ªåŠ¨åŒ–**: å»ºç«‹å®Œæ•´çš„ç›‘æ§ã€å‘Šè­¦å’Œè‡ªåŠ¨åŒ–éƒ¨ç½²ä½“ç³»

é€šè¿‡ç³»ç»Ÿæ€§çš„ä¼˜åŒ–å®æ–½ï¼ŒBlazorWebGameå°†å…·å¤‡æ”¯æŒå¤§è§„æ¨¡å•†ä¸šåŒ–è¿è¥çš„æŠ€æœ¯èƒ½åŠ›ï¼Œä¸ºç”¨æˆ·æä¾›æ›´ç¨³å®šã€æ›´é«˜æ•ˆçš„æ¸¸æˆä½“éªŒã€‚