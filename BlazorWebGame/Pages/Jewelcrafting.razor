@page "/jewelcrafting"
@using BlazorWebGame.Models
@using BlazorWebGame.Models.Items
@using BlazorWebGame.Services
@inject GameStateService GameState
@implements IDisposable

<PageTitle>珠宝加工</PageTitle>

@* --- vvv 核心修改：从检查 Player 改为检查 ActiveCharacter vvv --- *@
@if (GameState.ActiveCharacter is Player character)
{
    <div class="production-layout">
        <div class="header-section">
            <div class="profession-info">
                <h3>珠宝加工</h3>
                <div class="profession-stats">
                    <p>
                        等级: <strong>@character.GetLevel(ProductionProfession.Jewelcrafting)</strong>
                        (XP: @(character.ProductionProfessionXP.GetValueOrDefault(ProductionProfession.Jewelcrafting)))
                    </p>
                    <p>
                        制作速度加成: <strong>@((character.GetTotalCraftingSpeedBonus() * 100).ToString("F0"))%</strong>
                    </p>
                </div>
            </div>

            <div class="consumable-bar">
                <h5>生产食物</h5>
                <div class="consumable-quick-slots">
                    @for (int i = 0; i < 2; i++)
                    {
                        var slotId = i;
                        <div class="quick-slot"
                             @onclick="() => OpenQuickSlotPicker(ConsumableCategory.Food, slotId, FoodType.Production)"
                             @oncontextmenu="() => GameState.ClearQuickSlotItem(ConsumableCategory.Food, slotId, FoodType.Production)"
                             @oncontextmenu:preventDefault>
                            @if (character.ProductionFoodQuickSlots != null && character.ProductionFoodQuickSlots.TryGetValue(slotId, out var itemId) && !string.IsNullOrEmpty(itemId))
                            {
                                var item = ItemData.GetItemById(itemId);
                                if (item != null)
                                {
                                    var cooldown = character.ConsumableCooldowns.GetValueOrDefault(itemId, 0);
                                    var count = GetItemCountInInventory(character, itemId);
                                    <div class="quick-slot-item @(count == 0 ? "depleted" : "")" title="@item.Name (@count) - 右键清空">
                                        <div class="item-icon">@item.Name.Substring(0, 1)</div>
                                        <span class="item-count">@count</span>
                                        @if (cooldown > 0)
                                        {
                                            <div class="cooldown-overlay"><span>@((int)cooldown)</span></div>
                                        }
                                    </div>
                                }
                            }
                            else
                            {
                                <div class="quick-slot-empty" title="点击设置生产食物"></div>
                            }
                        </div>
                    }
                </div>
            </div>
        </div>

        @if (character.CurrentAction == PlayerActionState.Crafting && character.CurrentRecipe is Recipe currentRecipe)
        {
            <div class="current-action-card">
                <h4>正在制作: @currentRecipe.Name</h4>
                <div class="progress-bar-container">
                    <div class="progress-bar" style="width: @(GetCraftingProgress(character))%;"></div>
                    <span class="progress-text">@GetCurrentCraftingTime(character).ToString("F1")s</span>
                </div>
                <button class="btn btn-danger mt-3" @onclick="GameState.StopCurrentAction">停止制作</button>
            </div>
        }
        else if (character.CurrentAction != PlayerActionState.Idle)
        {
            <div class="action-blocked-card">
                <p><strong>@character.Name 正在进行其他活动，无法开始制作！</strong></p>
                <button class="btn btn-warning" @onclick="GameState.StopCurrentAction">停止当前活动</button>
            </div>
        }

        <div class="recipe-list">
            @foreach (var recipe in RecipeData.AllRecipes.Where(r => r.RequiredProfession == ProductionProfession.Jewelcrafting).OrderBy(r => r.RequiredLevel))
            {
                bool isLearned = recipe.IsDefault || character.LearnedRecipeIds.Contains(recipe.Id);
                bool canCraft = isLearned && character.GetLevel(ProductionProfession.Jewelcrafting) >= recipe.RequiredLevel;
                bool hasMaterials = CanAffordRecipe(character, recipe);

                <div class="recipe-card @(isLearned ? "" : "locked") @(canCraft ? "" : "level-locked")">
                    <div class="recipe-header">
                        <h5>@recipe.Name</h5>
                        <span class="recipe-level">Lv. @recipe.RequiredLevel</span>
                    </div>

                    <div class="recipe-details">
                        <div class="recipe-materials">
                            <h6>所需材料:</h6>
                            <ul>
                                @foreach (var ingredient in recipe.Ingredients)
                                {
                                    var item = ItemData.GetItemById(ingredient.Key);
                                    var ownedCount = GetItemCountInInventory(character, ingredient.Key);
                                    <li class="@(ownedCount >= ingredient.Value ? "has-mats" : "missing-mats")">
                                        @item?.Name: @ownedCount / @ingredient.Value
                                    </li>
                                }
                            </ul>
                        </div>
                        <div class="recipe-output">
                            <h6>产出:</h6>
                            <p>@ItemData.GetItemById(recipe.ResultingItemId)?.Name x @recipe.ResultingItemQuantity</p>
                        </div>
                    </div>

                    @if (isLearned)
                    {
                        @if (canCraft)
                        {
                            <button class="btn btn-success" @onclick="() => GameState.StartCrafting(recipe)" disabled="@(!hasMaterials || character.CurrentAction != PlayerActionState.Idle)">
                                @(hasMaterials ? "制作" : "材料不足")
                            </button>
                        }
                        else
                        {
                            <div class="lock-reason">需要珠宝加工等级 @recipe.RequiredLevel</div>
                        }
                    }
                    else
                    {
                        var unlockItem = ItemData.GetItemById(recipe.UnlockItemId ?? "");
                        <div class="lock-reason">
                            @if (unlockItem != null)
                            {
                                <span>需要图纸: @unlockItem.Name</span>
                            }
                            else
                            {
                                <span>通过其他方式解锁</span>
                            }
                        </div>
                    }
                </div>
            }
        </div>
    </div>
}
else
{
    <p>正在加载角色信息...</p>
}

@if (_isPickerVisible && GameState.ActiveCharacter is Player pickerCharacter)
{
    <div class="modal-backdrop" @onclick="CloseQuickSlotPicker"></div>
    <div class="quick-slot-picker">
        <h5>选择生产食物</h5>
        <div class="picker-item-list">
            @foreach (var item in GetAvailableConsumablesForPicker(pickerCharacter))
            {
                <div class="picker-item" @onclick="() => SetQuickSlot(item.Id)">
                    <span class="picker-item-name">@item.Name</span>
                    <span class="picker-item-count">(x@(GetItemCountInInventory(pickerCharacter, item.Id)))</span>
                </div>
            }
        </div>
        <button class="btn btn-secondary mt-2" @onclick="CloseQuickSlotPicker">关闭</button>
    </div>
}
@* --- ^^^ 修改结束 ^^^ --- *@


@code {
    private bool _isPickerVisible = false;
    private int _managingSlotId;
    private ConsumableCategory _managingCategory;
    private FoodType _managingFoodType;

    protected override void OnInitialized()
    {
        GameState.OnStateChanged += StateHasChanged;
    }

    // --- vvv 新增和修改的辅助方法 vvv ---

    private double GetCurrentCraftingTime(Player character)
    {
        if (character.CurrentRecipe == null) return 0;
        double speedBonus = character.GetTotalCraftingSpeedBonus();
        return character.CurrentRecipe.CraftingTimeSeconds / (1 + speedBonus);
    }

    private double GetCraftingProgress(Player character)
    {
        var totalTime = GetCurrentCraftingTime(character);
        if (totalTime <= 0) return 0;
        var progress = (totalTime - character.CraftingCooldown) / totalTime;
        return Math.Clamp(progress * 100, 0, 100);
    }

    private bool CanAffordRecipe(Player character, Recipe recipe)
    {
        foreach (var ingredient in recipe.Ingredients)
        {
            if (GetItemCountInInventory(character, ingredient.Key) < ingredient.Value)
            {
                return false;
            }
        }
        return true;
    }

    private int GetItemCountInInventory(Player character, string itemId)
    {
        return character.Inventory.Where(s => s.ItemId == itemId).Sum(s => s.Quantity);
    }

    private List<Consumable> GetAvailableConsumablesForPicker(Player character)
    {
        var itemIdsInInventory = character.Inventory
            .Where(s => !s.IsEmpty && s.ItemId != null)
            .Select(s => s.ItemId!)
            .ToHashSet();

        return ItemData.AllItems
            .OfType<Consumable>()
            .Where(c => c.FoodType == _managingFoodType && itemIdsInInventory.Contains(c.Id))
            .ToList();
    }

    // --- ^^^ 方法修改结束 ^^^ ---

    private void OpenQuickSlotPicker(ConsumableCategory category, int slotId, FoodType foodType)
    {
        _managingCategory = category;
        _managingSlotId = slotId;
        _managingFoodType = foodType;
        _isPickerVisible = true;
    }

    private void CloseQuickSlotPicker()
    {
        _isPickerVisible = false;
    }

    private void SetQuickSlot(string itemId)
    {
        GameState.SetQuickSlotItem(_managingCategory, _managingSlotId, itemId);
        CloseQuickSlotPicker();
    }

    public void Dispose()
    {
        GameState.OnStateChanged -= StateHasChanged;
    }
}