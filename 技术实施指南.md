# BlazorWebGame 前后端分离技术实施指南

## 实施概述

本指南提供BlazorWebGame前后端分离优化的具体技术实施方案，包含代码示例、配置文件和部署脚本，确保优化工作的顺利进行。

## 一、状态管理系统实施

### 1.1 创建统一状态管理器

#### 状态定义
```csharp
// GameState.cs - 全局游戏状态定义
namespace BlazorWebGame.Client.State
{
    public class GameState
    {
        public PlayerState Player { get; set; } = new();
        public InventoryState Inventory { get; set; } = new();
        public BattleState Battle { get; set; } = new();
        public UIState UI { get; set; } = new();
        public ConnectionState Connection { get; set; } = new();
    }

    public class PlayerState
    {
        public string? Id { get; set; }
        public string Name { get; set; } = "";
        public int Level { get; set; }
        public int Health { get; set; }
        public int MaxHealth { get; set; }
        public int Experience { get; set; }
        public Dictionary<string, int> Attributes { get; set; } = new();
        public Dictionary<string, int> ProfessionLevels { get; set; } = new();
    }

    public class InventoryState
    {
        public List<InventoryItem> Items { get; set; } = new();
        public int MaxSlots { get; set; } = 100;
        public Dictionary<string, EquippedItem> Equipment { get; set; } = new();
    }

    public class BattleState
    {
        public string? BattleId { get; set; }
        public bool IsInBattle { get; set; }
        public List<BattleParticipant> Players { get; set; } = new();
        public List<BattleParticipant> Enemies { get; set; } = new();
        public BattleStatus Status { get; set; } = BattleStatus.NotInBattle;
    }

    public class UIState
    {
        public bool IsLoading { get; set; }
        public string? ErrorMessage { get; set; }
        public Dictionary<string, bool> PanelVisibility { get; set; } = new();
        public string CurrentPage { get; set; } = "";
    }

    public class ConnectionState
    {
        public bool IsOnline { get; set; } = true;
        public bool IsConnectedToServer { get; set; }
        public DateTime LastSync { get; set; }
        public int PendingOperations { get; set; }
    }
}
```

#### 动作定义
```csharp
// GameActions.cs - 游戏动作定义
namespace BlazorWebGame.Client.State
{
    public abstract class GameAction
    {
        public DateTime Timestamp { get; set; } = DateTime.UtcNow;
        public string ActionId { get; set; } = Guid.NewGuid().ToString();
    }

    // 玩家相关动作
    public class UpdatePlayerAction : GameAction
    {
        public string PlayerId { get; set; } = "";
        public Dictionary<string, object> Updates { get; set; } = new();
    }

    public class UpdatePlayerHealthAction : GameAction
    {
        public int NewHealth { get; set; }
        public int MaxHealth { get; set; }
    }

    // 库存相关动作
    public class AddItemAction : GameAction
    {
        public InventoryItem Item { get; set; } = new();
        public int Quantity { get; set; } = 1;
    }

    public class RemoveItemAction : GameAction
    {
        public string ItemId { get; set; } = "";
        public int Quantity { get; set; } = 1;
    }

    // 战斗相关动作
    public class StartBattleAction : GameAction
    {
        public string EnemyId { get; set; } = "";
        public string? PartyId { get; set; }
    }

    public class UpdateBattleStateAction : GameAction
    {
        public BattleStateDto BattleState { get; set; } = new();
    }

    // UI相关动作
    public class SetLoadingAction : GameAction
    {
        public bool IsLoading { get; set; }
        public string? Message { get; set; }
    }

    public class SetErrorAction : GameAction
    {
        public string? ErrorMessage { get; set; }
    }

    // 连接相关动作
    public class UpdateConnectionAction : GameAction
    {
        public bool IsOnline { get; set; }
        public bool IsConnectedToServer { get; set; }
    }
}
```

#### 状态减少器(Reducer)
```csharp
// GameReducer.cs - 状态更新逻辑
namespace BlazorWebGame.Client.State
{
    public static class GameReducer
    {
        public static GameState Reduce(GameState state, GameAction action)
        {
            var newState = state.DeepClone(); // 实现深拷贝以保证不可变性

            return action switch
            {
                UpdatePlayerAction updatePlayer => ReducePlayerUpdate(newState, updatePlayer),
                UpdatePlayerHealthAction updateHealth => ReduceHealthUpdate(newState, updateHealth),
                AddItemAction addItem => ReduceAddItem(newState, addItem),
                RemoveItemAction removeItem => ReduceRemoveItem(newState, removeItem),
                StartBattleAction startBattle => ReduceStartBattle(newState, startBattle),
                UpdateBattleStateAction updateBattle => ReduceUpdateBattle(newState, updateBattle),
                SetLoadingAction setLoading => ReduceSetLoading(newState, setLoading),
                SetErrorAction setError => ReduceSetError(newState, setError),
                UpdateConnectionAction updateConnection => ReduceUpdateConnection(newState, updateConnection),
                _ => newState
            };
        }

        private static GameState ReducePlayerUpdate(GameState state, UpdatePlayerAction action)
        {
            foreach (var update in action.Updates)
            {
                switch (update.Key.ToLower())
                {
                    case "level":
                        state.Player.Level = Convert.ToInt32(update.Value);
                        break;
                    case "experience":
                        state.Player.Experience = Convert.ToInt32(update.Value);
                        break;
                    case "name":
                        state.Player.Name = update.Value.ToString() ?? "";
                        break;
                }
            }
            return state;
        }

        private static GameState ReduceHealthUpdate(GameState state, UpdatePlayerHealthAction action)
        {
            state.Player.Health = action.NewHealth;
            state.Player.MaxHealth = action.MaxHealth;
            return state;
        }

        private static GameState ReduceAddItem(GameState state, AddItemAction action)
        {
            var existingItem = state.Inventory.Items.FirstOrDefault(i => i.Id == action.Item.Id);
            if (existingItem != null)
            {
                existingItem.Quantity += action.Quantity;
            }
            else
            {
                action.Item.Quantity = action.Quantity;
                state.Inventory.Items.Add(action.Item);
            }
            return state;
        }

        private static GameState ReduceRemoveItem(GameState state, RemoveItemAction action)
        {
            var item = state.Inventory.Items.FirstOrDefault(i => i.Id == action.ItemId);
            if (item != null)
            {
                item.Quantity -= action.Quantity;
                if (item.Quantity <= 0)
                {
                    state.Inventory.Items.Remove(item);
                }
            }
            return state;
        }

        private static GameState ReduceStartBattle(GameState state, StartBattleAction action)
        {
            state.Battle.IsInBattle = true;
            state.Battle.Status = BattleStatus.Starting;
            return state;
        }

        private static GameState ReduceUpdateBattle(GameState state, UpdateBattleStateAction action)
        {
            state.Battle.BattleId = action.BattleState.BattleId.ToString();
            state.Battle.IsInBattle = action.BattleState.IsActive;
            state.Battle.Status = action.BattleState.Status;
            // 更新战斗参与者信息
            state.Battle.Players = action.BattleState.Players.ToList();
            state.Battle.Enemies = action.BattleState.Enemies.ToList();
            return state;
        }

        private static GameState ReduceSetLoading(GameState state, SetLoadingAction action)
        {
            state.UI.IsLoading = action.IsLoading;
            return state;
        }

        private static GameState ReduceSetError(GameState state, SetErrorAction action)
        {
            state.UI.ErrorMessage = action.ErrorMessage;
            return state;
        }

        private static GameState ReduceUpdateConnection(GameState state, UpdateConnectionAction action)
        {
            state.Connection.IsOnline = action.IsOnline;
            state.Connection.IsConnectedToServer = action.IsConnectedToServer;
            state.Connection.LastSync = DateTime.UtcNow;
            return state;
        }
    }
}
```

#### 状态存储器(Store)
```csharp
// GameStore.cs - 状态管理核心
namespace BlazorWebGame.Client.State
{
    public class GameStore : IDisposable
    {
        private GameState _state = new();
        private readonly List<Func<GameState, Task>> _subscribers = new();
        private readonly List<Func<GameAction, GameAction, Task>> _middlewares = new();
        private readonly SemaphoreSlim _stateLock = new(1, 1);
        private readonly ILogger<GameStore> _logger;

        public GameState State => _state;
        public event Action<GameState>? StateChanged;

        public GameStore(ILogger<GameStore> logger)
        {
            _logger = logger;
        }

        public async Task DispatchAsync(GameAction action)
        {
            await _stateLock.WaitAsync();
            try
            {
                _logger.LogDebug("Dispatching action: {ActionType}", action.GetType().Name);

                // 执行中间件
                var processedAction = action;
                foreach (var middleware in _middlewares)
                {
                    await middleware(processedAction, action);
                }

                // 更新状态
                var newState = GameReducer.Reduce(_state, processedAction);
                
                if (!ReferenceEquals(_state, newState))
                {
                    _state = newState;
                    StateChanged?.Invoke(_state);

                    // 通知订阅者
                    var tasks = _subscribers.Select(subscriber => subscriber(_state));
                    await Task.WhenAll(tasks);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error dispatching action: {ActionType}", action.GetType().Name);
                throw;
            }
            finally
            {
                _stateLock.Release();
            }
        }

        public void Subscribe(Func<GameState, Task> subscriber)
        {
            _subscribers.Add(subscriber);
        }

        public void AddMiddleware(Func<GameAction, GameAction, Task> middleware)
        {
            _middlewares.Add(middleware);
        }

        public void Dispose()
        {
            _stateLock?.Dispose();
        }
    }
}
```

### 1.2 状态管理中间件

#### 日志中间件
```csharp
// LoggingMiddleware.cs
namespace BlazorWebGame.Client.State.Middleware
{
    public class LoggingMiddleware
    {
        private readonly ILogger<LoggingMiddleware> _logger;

        public LoggingMiddleware(ILogger<LoggingMiddleware> logger)
        {
            _logger = logger;
        }

        public async Task ProcessAsync(GameAction currentAction, GameAction originalAction)
        {
            _logger.LogInformation("Action dispatched: {ActionType} at {Timestamp}", 
                currentAction.GetType().Name, currentAction.Timestamp);
            
            await Task.CompletedTask;
        }
    }
}
```

#### 持久化中间件
```csharp
// PersistenceMiddleware.cs
namespace BlazorWebGame.Client.State.Middleware
{
    public class PersistenceMiddleware
    {
        private readonly GameStorage _storage;
        private readonly ILogger<PersistenceMiddleware> _logger;

        public PersistenceMiddleware(GameStorage storage, ILogger<PersistenceMiddleware> logger)
        {
            _storage = storage;
            _logger = logger;
        }

        public async Task ProcessAsync(GameAction currentAction, GameAction originalAction)
        {
            try
            {
                // 保存关键状态到本地存储
                if (ShouldPersist(currentAction))
                {
                    await _storage.SaveGameStateAsync(currentAction);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to persist action: {ActionType}", currentAction.GetType().Name);
            }
        }

        private bool ShouldPersist(GameAction action)
        {
            return action is UpdatePlayerAction or AddItemAction or RemoveItemAction;
        }
    }
}
```

#### API同步中间件
```csharp
// ApiSyncMiddleware.cs
namespace BlazorWebGame.Client.State.Middleware
{
    public class ApiSyncMiddleware
    {
        private readonly GameApiClient _apiClient;
        private readonly ILogger<ApiSyncMiddleware> _logger;

        public ApiSyncMiddleware(GameApiClient apiClient, ILogger<ApiSyncMiddleware> logger)
        {
            _apiClient = apiClient;
            _logger = logger;
        }

        public async Task ProcessAsync(GameAction currentAction, GameAction originalAction)
        {
            try
            {
                // 同步到服务器
                if (ShouldSync(currentAction))
                {
                    await SyncToServer(currentAction);
                }
            }
            catch (Exception ex)
            {
                _logger.LogWarning(ex, "Failed to sync action to server: {ActionType}", currentAction.GetType().Name);
                // 添加到离线队列
                await AddToOfflineQueue(currentAction);
            }
        }

        private bool ShouldSync(GameAction action)
        {
            return action is StartBattleAction or AddItemAction or RemoveItemAction;
        }

        private async Task SyncToServer(GameAction action)
        {
            switch (action)
            {
                case StartBattleAction startBattle:
                    await _apiClient.Battle.StartBattleAsync(new StartBattleRequest
                    {
                        CharacterId = startBattle.ActionId, // 临时实现
                        EnemyId = startBattle.EnemyId,
                        PartyId = startBattle.PartyId
                    });
                    break;
                    
                case AddItemAction addItem:
                    await _apiClient.Inventory.AddItemAsync(new AddItemRequest
                    {
                        ItemId = addItem.Item.Id,
                        Quantity = addItem.Quantity
                    });
                    break;
            }
        }

        private async Task AddToOfflineQueue(GameAction action)
        {
            // 实现离线队列逻辑
            await Task.CompletedTask;
        }
    }
}
```

## 二、API标准化实施

### 2.1 RESTful API控制器重构

#### 标准化的控制器基类
```csharp
// BaseApiController.cs
namespace BlazorWebGame.Server.Controllers
{
    [ApiController]
    [Route("api/v1/[controller]")]
    [Produces("application/json")]
    [ProducesResponseType(typeof(ProblemDetails), StatusCodes.Status400BadRequest)]
    [ProducesResponseType(typeof(ProblemDetails), StatusCodes.Status500InternalServerError)]
    public abstract class BaseApiController : ControllerBase
    {
        protected readonly ILogger _logger;

        protected BaseApiController(ILogger logger)
        {
            _logger = logger;
        }

        protected ActionResult<ApiResponse<T>> Success<T>(T data, string message = "Operation successful")
        {
            return Ok(new ApiResponse<T>
            {
                Success = true,
                Data = data,
                Message = message,
                Timestamp = DateTime.UtcNow
            });
        }

        protected ActionResult<ApiResponse<T>> Error<T>(string message, List<string>? errors = null)
        {
            return BadRequest(new ApiResponse<T>
            {
                Success = false,
                Message = message,
                Errors = errors ?? new List<string>(),
                Timestamp = DateTime.UtcNow
            });
        }

        protected ActionResult<ApiResponse<T>> NotFound<T>(string message = "Resource not found")
        {
            return NotFound(new ApiResponse<T>
            {
                Success = false,
                Message = message,
                Timestamp = DateTime.UtcNow
            });
        }
    }
}
```

#### 重构后的角色控制器
```csharp
// CharactersController.cs
namespace BlazorWebGame.Server.Controllers
{
    [Authorize]
    public class CharactersController : BaseApiController
    {
        private readonly ICharacterService _characterService;
        private readonly IMapper _mapper;

        public CharactersController(
            ICharacterService characterService, 
            IMapper mapper,
            ILogger<CharactersController> logger) : base(logger)
        {
            _characterService = characterService;
            _mapper = mapper;
        }

        /// <summary>
        /// 获取用户的所有角色
        /// </summary>
        [HttpGet]
        [ProducesResponseType(typeof(ApiResponse<List<CharacterDto>>), StatusCodes.Status200OK)]
        public async Task<ActionResult<ApiResponse<List<CharacterDto>>>> GetCharacters()
        {
            try
            {
                var userId = GetCurrentUserId();
                var characters = await _characterService.GetCharactersByUserIdAsync(userId);
                var characterDtos = _mapper.Map<List<CharacterDto>>(characters);
                
                return Success(characterDtos);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to get characters");
                return Error<List<CharacterDto>>("Failed to retrieve characters");
            }
        }

        /// <summary>
        /// 获取指定角色详情
        /// </summary>
        [HttpGet("{characterId}")]
        [ProducesResponseType(typeof(ApiResponse<CharacterDetailDto>), StatusCodes.Status200OK)]
        [ProducesResponseType(typeof(ApiResponse<CharacterDetailDto>), StatusCodes.Status404NotFound)]
        public async Task<ActionResult<ApiResponse<CharacterDetailDto>>> GetCharacter(string characterId)
        {
            try
            {
                var userId = GetCurrentUserId();
                var character = await _characterService.GetCharacterByIdAsync(characterId);
                
                if (character == null || character.UserId != userId)
                {
                    return NotFound<CharacterDetailDto>("Character not found");
                }

                var characterDto = _mapper.Map<CharacterDetailDto>(character);
                return Success(characterDto);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to get character {CharacterId}", characterId);
                return Error<CharacterDetailDto>("Failed to retrieve character");
            }
        }

        /// <summary>
        /// 创建新角色
        /// </summary>
        [HttpPost]
        [ProducesResponseType(typeof(ApiResponse<CharacterDto>), StatusCodes.Status201Created)]
        public async Task<ActionResult<ApiResponse<CharacterDto>>> CreateCharacter([FromBody] CreateCharacterRequest request)
        {
            try
            {
                if (!ModelState.IsValid)
                {
                    var errors = ModelState.Values.SelectMany(v => v.Errors).Select(e => e.ErrorMessage).ToList();
                    return Error<CharacterDto>("Invalid request data", errors);
                }

                var userId = GetCurrentUserId();
                var character = await _characterService.CreateCharacterAsync(userId, request);
                var characterDto = _mapper.Map<CharacterDto>(character);
                
                return CreatedAtAction(nameof(GetCharacter), new { characterId = character.Id }, Success(characterDto));
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to create character");
                return Error<CharacterDto>("Failed to create character");
            }
        }

        /// <summary>
        /// 更新角色信息
        /// </summary>
        [HttpPut("{characterId}")]
        [ProducesResponseType(typeof(ApiResponse<CharacterDto>), StatusCodes.Status200OK)]
        public async Task<ActionResult<ApiResponse<CharacterDto>>> UpdateCharacter(
            string characterId, 
            [FromBody] UpdateCharacterRequest request)
        {
            try
            {
                var userId = GetCurrentUserId();
                var character = await _characterService.UpdateCharacterAsync(userId, characterId, request);
                
                if (character == null)
                {
                    return NotFound<CharacterDto>("Character not found");
                }

                var characterDto = _mapper.Map<CharacterDto>(character);
                return Success(characterDto);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to update character {CharacterId}", characterId);
                return Error<CharacterDto>("Failed to update character");
            }
        }

        /// <summary>
        /// 删除角色
        /// </summary>
        [HttpDelete("{characterId}")]
        [ProducesResponseType(typeof(ApiResponse<bool>), StatusCodes.Status200OK)]
        public async Task<ActionResult<ApiResponse<bool>>> DeleteCharacter(string characterId)
        {
            try
            {
                var userId = GetCurrentUserId();
                var success = await _characterService.DeleteCharacterAsync(userId, characterId);
                
                if (!success)
                {
                    return NotFound<bool>("Character not found");
                }

                return Success(true, "Character deleted successfully");
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to delete character {CharacterId}", characterId);
                return Error<bool>("Failed to delete character");
            }
        }

        /// <summary>
        /// 获取角色库存
        /// </summary>
        [HttpGet("{characterId}/inventory")]
        [ProducesResponseType(typeof(ApiResponse<InventoryDto>), StatusCodes.Status200OK)]
        public async Task<ActionResult<ApiResponse<InventoryDto>>> GetCharacterInventory(string characterId)
        {
            try
            {
                var userId = GetCurrentUserId();
                var inventory = await _characterService.GetCharacterInventoryAsync(userId, characterId);
                
                if (inventory == null)
                {
                    return NotFound<InventoryDto>("Character or inventory not found");
                }

                var inventoryDto = _mapper.Map<InventoryDto>(inventory);
                return Success(inventoryDto);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to get inventory for character {CharacterId}", characterId);
                return Error<InventoryDto>("Failed to retrieve inventory");
            }
        }

        /// <summary>
        /// 获取角色装备
        /// </summary>
        [HttpGet("{characterId}/equipment")]
        [ProducesResponseType(typeof(ApiResponse<EquipmentDto>), StatusCodes.Status200OK)]
        public async Task<ActionResult<ApiResponse<EquipmentDto>>> GetCharacterEquipment(string characterId)
        {
            try
            {
                var userId = GetCurrentUserId();
                var equipment = await _characterService.GetCharacterEquipmentAsync(userId, characterId);
                
                if (equipment == null)
                {
                    return NotFound<EquipmentDto>("Character or equipment not found");
                }

                var equipmentDto = _mapper.Map<EquipmentDto>(equipment);
                return Success(equipmentDto);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to get equipment for character {CharacterId}", characterId);
                return Error<EquipmentDto>("Failed to retrieve equipment");
            }
        }

        private string GetCurrentUserId()
        {
            return User.FindFirst("userId")?.Value ?? throw new UnauthorizedAccessException("User ID not found in token");
        }
    }
}
```

### 2.2 DTO和验证规则

#### 请求DTO定义
```csharp
// CharacterDTOs.cs
namespace BlazorWebGame.Shared.DTOs
{
    public class CreateCharacterRequest
    {
        [Required(ErrorMessage = "Character name is required")]
        [StringLength(50, MinimumLength = 2, ErrorMessage = "Character name must be between 2 and 50 characters")]
        public string Name { get; set; } = "";

        [Required(ErrorMessage = "Character class is required")]
        public string CharacterClass { get; set; } = "";

        [Range(1, 100, ErrorMessage = "Starting level must be between 1 and 100")]
        public int StartingLevel { get; set; } = 1;
    }

    public class UpdateCharacterRequest
    {
        [StringLength(50, MinimumLength = 2, ErrorMessage = "Character name must be between 2 and 50 characters")]
        public string? Name { get; set; }

        public Dictionary<string, int>? AttributeUpdates { get; set; }
        public Dictionary<string, int>? ProfessionLevelUpdates { get; set; }
        public List<string>? EquippedSkillIds { get; set; }
    }

    public class CharacterDto
    {
        public string Id { get; set; } = "";
        public string Name { get; set; } = "";
        public string CharacterClass { get; set; } = "";
        public int Level { get; set; }
        public int Experience { get; set; }
        public int Health { get; set; }
        public int MaxHealth { get; set; }
        public int Mana { get; set; }
        public int MaxMana { get; set; }
        public DateTime CreatedAt { get; set; }
        public DateTime LastPlayed { get; set; }
    }

    public class CharacterDetailDto : CharacterDto
    {
        public AttributesDto Attributes { get; set; } = new();
        public Dictionary<string, int> ProfessionLevels { get; set; } = new();
        public PlayerActionState CurrentAction { get; set; }
        public List<string> EquippedSkillIds { get; set; } = new();
        public Dictionary<string, string> Equipment { get; set; } = new();
        public StatisticsDto Statistics { get; set; } = new();
    }

    public class AttributesDto
    {
        public int Strength { get; set; }
        public int Agility { get; set; }
        public int Intellect { get; set; }
        public int Spirit { get; set; }
        public int Stamina { get; set; }
        public int Luck { get; set; }
    }

    public class StatisticsDto
    {
        public int TotalBattles { get; set; }
        public int BattlesWon { get; set; }
        public int TotalItemsCrafted { get; set; }
        public int TotalGoldEarned { get; set; }
        public TimeSpan TotalPlayTime { get; set; }
    }
}
```

#### 自定义验证特性
```csharp
// ValidationAttributes.cs
namespace BlazorWebGame.Server.Validation
{
    public class ValidCharacterClassAttribute : ValidationAttribute
    {
        private readonly string[] _validClasses = { "Warrior", "Mage", "Archer", "Rogue" };

        protected override ValidationResult? IsValid(object? value, ValidationContext validationContext)
        {
            if (value is string characterClass && _validClasses.Contains(characterClass))
            {
                return ValidationResult.Success;
            }

            return new ValidationResult($"Character class must be one of: {string.Join(", ", _validClasses)}");
        }
    }

    public class ValidSkillIdAttribute : ValidationAttribute
    {
        protected override ValidationResult? IsValid(object? value, ValidationContext validationContext)
        {
            if (value is List<string> skillIds)
            {
                var skillService = validationContext.GetService<ISkillService>();
                if (skillService == null)
                {
                    return new ValidationResult("Skill validation service not available");
                }

                foreach (var skillId in skillIds)
                {
                    if (!skillService.IsValidSkillId(skillId))
                    {
                        return new ValidationResult($"Invalid skill ID: {skillId}");
                    }
                }
            }

            return ValidationResult.Success;
        }
    }
}
```

## 三、认证授权系统实施

### 3.1 JWT认证配置

#### JWT配置类
```csharp
// JwtSettings.cs
namespace BlazorWebGame.Server.Configuration
{
    public class JwtSettings
    {
        public string SecretKey { get; set; } = "";
        public string Issuer { get; set; } = "";
        public string Audience { get; set; } = "";
        public int ExpirationMinutes { get; set; } = 60;
        public int RefreshTokenExpirationDays { get; set; } = 7;
    }
}
```

#### 认证服务实现
```csharp
// AuthService.cs
namespace BlazorWebGame.Server.Services
{
    public interface IAuthService
    {
        Task<AuthResult> LoginAsync(LoginRequest request);
        Task<AuthResult> RefreshTokenAsync(string refreshToken);
        Task<bool> RevokeTokenAsync(string token);
        Task<AuthResult> RegisterAsync(RegisterRequest request);
    }

    public class AuthService : IAuthService
    {
        private readonly IUserRepository _userRepository;
        private readonly ITokenService _tokenService;
        private readonly IPasswordHasher _passwordHasher;
        private readonly ILogger<AuthService> _logger;

        public AuthService(
            IUserRepository userRepository,
            ITokenService tokenService,
            IPasswordHasher passwordHasher,
            ILogger<AuthService> logger)
        {
            _userRepository = userRepository;
            _tokenService = tokenService;
            _passwordHasher = passwordHasher;
            _logger = logger;
        }

        public async Task<AuthResult> LoginAsync(LoginRequest request)
        {
            try
            {
                var user = await _userRepository.GetByEmailAsync(request.Email);
                if (user == null || !_passwordHasher.VerifyPassword(request.Password, user.PasswordHash))
                {
                    return AuthResult.Failed("Invalid email or password");
                }

                if (!user.IsActive)
                {
                    return AuthResult.Failed("Account is disabled");
                }

                var accessToken = _tokenService.GenerateAccessToken(user);
                var refreshToken = _tokenService.GenerateRefreshToken();

                // 保存刷新令牌
                user.RefreshToken = refreshToken;
                user.RefreshTokenExpiry = DateTime.UtcNow.AddDays(7);
                await _userRepository.UpdateAsync(user);

                _logger.LogInformation("User {UserId} logged in successfully", user.Id);

                return AuthResult.Success(accessToken, refreshToken, user);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Login failed for email {Email}", request.Email);
                return AuthResult.Failed("Login failed");
            }
        }

        public async Task<AuthResult> RefreshTokenAsync(string refreshToken)
        {
            try
            {
                var user = await _userRepository.GetByRefreshTokenAsync(refreshToken);
                if (user == null || user.RefreshTokenExpiry < DateTime.UtcNow)
                {
                    return AuthResult.Failed("Invalid refresh token");
                }

                var accessToken = _tokenService.GenerateAccessToken(user);
                var newRefreshToken = _tokenService.GenerateRefreshToken();

                user.RefreshToken = newRefreshToken;
                user.RefreshTokenExpiry = DateTime.UtcNow.AddDays(7);
                await _userRepository.UpdateAsync(user);

                return AuthResult.Success(accessToken, newRefreshToken, user);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Token refresh failed");
                return AuthResult.Failed("Token refresh failed");
            }
        }

        public async Task<bool> RevokeTokenAsync(string token)
        {
            try
            {
                var user = await _userRepository.GetByRefreshTokenAsync(token);
                if (user != null)
                {
                    user.RefreshToken = null;
                    user.RefreshTokenExpiry = null;
                    await _userRepository.UpdateAsync(user);
                    return true;
                }
                return false;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Token revocation failed");
                return false;
            }
        }

        public async Task<AuthResult> RegisterAsync(RegisterRequest request)
        {
            try
            {
                // 检查邮箱是否已存在
                var existingUser = await _userRepository.GetByEmailAsync(request.Email);
                if (existingUser != null)
                {
                    return AuthResult.Failed("Email already exists");
                }

                // 创建新用户
                var user = new User
                {
                    Id = Guid.NewGuid().ToString(),
                    Email = request.Email,
                    Username = request.Username,
                    PasswordHash = _passwordHasher.HashPassword(request.Password),
                    IsActive = true,
                    CreatedAt = DateTime.UtcNow
                };

                await _userRepository.CreateAsync(user);

                _logger.LogInformation("New user registered: {UserId}", user.Id);

                return await LoginAsync(new LoginRequest { Email = request.Email, Password = request.Password });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Registration failed for email {Email}", request.Email);
                return AuthResult.Failed("Registration failed");
            }
        }
    }
}
```

#### Token服务实现
```csharp
// TokenService.cs
namespace BlazorWebGame.Server.Services
{
    public interface ITokenService
    {
        string GenerateAccessToken(User user);
        string GenerateRefreshToken();
        ClaimsPrincipal? GetPrincipalFromExpiredToken(string token);
    }

    public class TokenService : ITokenService
    {
        private readonly JwtSettings _jwtSettings;
        private readonly ILogger<TokenService> _logger;

        public TokenService(IOptions<JwtSettings> jwtSettings, ILogger<TokenService> logger)
        {
            _jwtSettings = jwtSettings.Value;
            _logger = logger;
        }

        public string GenerateAccessToken(User user)
        {
            var claims = new[]
            {
                new Claim("userId", user.Id),
                new Claim(ClaimTypes.Email, user.Email),
                new Claim(ClaimTypes.Name, user.Username),
                new Claim("role", user.Role),
                new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString()),
                new Claim(JwtRegisteredClaimNames.Iat, DateTimeOffset.UtcNow.ToUnixTimeSeconds().ToString(), ClaimValueTypes.Integer64)
            };

            var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_jwtSettings.SecretKey));
            var credentials = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);

            var token = new JwtSecurityToken(
                issuer: _jwtSettings.Issuer,
                audience: _jwtSettings.Audience,
                claims: claims,
                expires: DateTime.UtcNow.AddMinutes(_jwtSettings.ExpirationMinutes),
                signingCredentials: credentials
            );

            return new JwtSecurityTokenHandler().WriteToken(token);
        }

        public string GenerateRefreshToken()
        {
            var randomBytes = new byte[32];
            using var rng = RandomNumberGenerator.Create();
            rng.GetBytes(randomBytes);
            return Convert.ToBase64String(randomBytes);
        }

        public ClaimsPrincipal? GetPrincipalFromExpiredToken(string token)
        {
            try
            {
                var tokenHandler = new JwtSecurityTokenHandler();
                var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_jwtSettings.SecretKey));

                var parameters = new TokenValidationParameters
                {
                    ValidateIssuer = true,
                    ValidateAudience = true,
                    ValidateLifetime = false, // 允许过期token
                    ValidateIssuerSigningKey = true,
                    ValidIssuer = _jwtSettings.Issuer,
                    ValidAudience = _jwtSettings.Audience,
                    IssuerSigningKey = key,
                    ClockSkew = TimeSpan.Zero
                };

                var principal = tokenHandler.ValidateToken(token, parameters, out _);
                return principal;
            }
            catch (Exception ex)
            {
                _logger.LogWarning(ex, "Failed to get principal from expired token");
                return null;
            }
        }
    }
}
```

### 3.2 前端Token管理

#### Token存储服务
```csharp
// TokenStorageService.cs
namespace BlazorWebGame.Client.Services
{
    public interface ITokenStorageService
    {
        Task<string?> GetTokenAsync();
        Task SetTokenAsync(string token);
        Task<string?> GetRefreshTokenAsync();
        Task SetRefreshTokenAsync(string refreshToken);
        Task ClearTokensAsync();
        Task<bool> IsTokenValidAsync();
    }

    public class TokenStorageService : ITokenStorageService
    {
        private readonly ILocalStorageService _localStorage;
        private readonly IJSRuntime _jsRuntime;
        private readonly ILogger<TokenStorageService> _logger;

        private const string ACCESS_TOKEN_KEY = "game_access_token";
        private const string REFRESH_TOKEN_KEY = "game_refresh_token";

        public TokenStorageService(
            ILocalStorageService localStorage,
            IJSRuntime jsRuntime,
            ILogger<TokenStorageService> logger)
        {
            _localStorage = localStorage;
            _jsRuntime = jsRuntime;
            _logger = logger;
        }

        public async Task<string?> GetTokenAsync()
        {
            try
            {
                return await _localStorage.GetItemAsync<string>(ACCESS_TOKEN_KEY);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to get access token");
                return null;
            }
        }

        public async Task SetTokenAsync(string token)
        {
            try
            {
                await _localStorage.SetItemAsync(ACCESS_TOKEN_KEY, token);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to set access token");
            }
        }

        public async Task<string?> GetRefreshTokenAsync()
        {
            try
            {
                return await _localStorage.GetItemAsync<string>(REFRESH_TOKEN_KEY);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to get refresh token");
                return null;
            }
        }

        public async Task SetRefreshTokenAsync(string refreshToken)
        {
            try
            {
                await _localStorage.SetItemAsync(REFRESH_TOKEN_KEY, refreshToken);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to set refresh token");
            }
        }

        public async Task ClearTokensAsync()
        {
            try
            {
                await _localStorage.RemoveItemAsync(ACCESS_TOKEN_KEY);
                await _localStorage.RemoveItemAsync(REFRESH_TOKEN_KEY);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to clear tokens");
            }
        }

        public async Task<bool> IsTokenValidAsync()
        {
            try
            {
                var token = await GetTokenAsync();
                if (string.IsNullOrEmpty(token))
                    return false;

                // 使用JS来解析JWT token并检查过期时间
                var isValid = await _jsRuntime.InvokeAsync<bool>("isTokenValid", token);
                return isValid;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to validate token");
                return false;
            }
        }
    }
}
```

#### 认证HTTP客户端
```csharp
// AuthenticatedHttpClient.cs
namespace BlazorWebGame.Client.Services
{
    public class AuthenticatedHttpClient
    {
        private readonly HttpClient _httpClient;
        private readonly ITokenStorageService _tokenStorage;
        private readonly ILogger<AuthenticatedHttpClient> _logger;

        public AuthenticatedHttpClient(
            HttpClient httpClient,
            ITokenStorageService tokenStorage,
            ILogger<AuthenticatedHttpClient> logger)
        {
            _httpClient = httpClient;
            _tokenStorage = tokenStorage;
            _logger = logger;
        }

        public async Task<HttpResponseMessage> SendAsync(HttpRequestMessage request)
        {
            // 添加认证头
            await AddAuthenticationHeaderAsync(request);

            var response = await _httpClient.SendAsync(request);

            // 如果token过期，尝试刷新
            if (response.StatusCode == HttpStatusCode.Unauthorized)
            {
                var refreshed = await RefreshTokenAsync();
                if (refreshed)
                {
                    // 重新添加认证头并重试
                    await AddAuthenticationHeaderAsync(request);
                    response = await _httpClient.SendAsync(request);
                }
            }

            return response;
        }

        private async Task AddAuthenticationHeaderAsync(HttpRequestMessage request)
        {
            var token = await _tokenStorage.GetTokenAsync();
            if (!string.IsNullOrEmpty(token))
            {
                request.Headers.Authorization = new AuthenticationHeaderValue("Bearer", token);
            }
        }

        private async Task<bool> RefreshTokenAsync()
        {
            try
            {
                var refreshToken = await _tokenStorage.GetRefreshTokenAsync();
                if (string.IsNullOrEmpty(refreshToken))
                    return false;

                var refreshRequest = new HttpRequestMessage(HttpMethod.Post, "/api/v1/auth/refresh")
                {
                    Content = JsonContent.Create(new { refreshToken })
                };

                var response = await _httpClient.SendAsync(refreshRequest);
                if (response.IsSuccessStatusCode)
                {
                    var authResult = await response.Content.ReadFromJsonAsync<AuthResult>();
                    if (authResult?.Success == true)
                    {
                        await _tokenStorage.SetTokenAsync(authResult.AccessToken);
                        await _tokenStorage.SetRefreshTokenAsync(authResult.RefreshToken);
                        return true;
                    }
                }

                // 刷新失败，清除token
                await _tokenStorage.ClearTokensAsync();
                return false;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Token refresh failed");
                await _tokenStorage.ClearTokensAsync();
                return false;
            }
        }
    }
}
```

## 四、部署配置

### 4.1 Docker配置

#### 客户端Dockerfile
```dockerfile
# BlazorWebGame.Client/Dockerfile
FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build
WORKDIR /src

# 复制项目文件
COPY ["src/BlazorWebGame.Client/BlazorWebGame.csproj", "src/BlazorWebGame.Client/"]
COPY ["src/BlazorWebGame.Shared/BlazorWebGame.Shared.csproj", "src/BlazorWebGame.Shared/"]

# 还原依赖
RUN dotnet restore "src/BlazorWebGame.Client/BlazorWebGame.csproj"

# 复制所有文件并构建
COPY . .
WORKDIR "/src/src/BlazorWebGame.Client"
RUN dotnet build "BlazorWebGame.csproj" -c Release -o /app/build

# 发布应用
FROM build AS publish
RUN dotnet publish "BlazorWebGame.csproj" -c Release -o /app/publish

# 使用nginx托管静态文件
FROM nginx:alpine AS final
COPY --from=publish /app/publish/wwwroot /usr/share/nginx/html
COPY nginx.conf /etc/nginx/nginx.conf

EXPOSE 80
```

#### 服务端Dockerfile
```dockerfile
# BlazorWebGame.Server/Dockerfile
FROM mcr.microsoft.com/dotnet/aspnet:8.0 AS base
WORKDIR /app
EXPOSE 80
EXPOSE 443

FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build
WORKDIR /src

# 复制项目文件
COPY ["src/BlazorWebGame.Server/BlazorWebGame.Server.csproj", "src/BlazorWebGame.Server/"]
COPY ["src/BlazorWebGame.Shared/BlazorWebGame.Shared.csproj", "src/BlazorWebGame.Shared/"]

# 还原依赖
RUN dotnet restore "src/BlazorWebGame.Server/BlazorWebGame.Server.csproj"

# 复制所有文件并构建
COPY . .
WORKDIR "/src/src/BlazorWebGame.Server"
RUN dotnet build "BlazorWebGame.Server.csproj" -c Release -o /app/build

# 发布应用
FROM build AS publish
RUN dotnet publish "BlazorWebGame.Server.csproj" -c Release -o /app/publish

# 最终镜像
FROM base AS final
WORKDIR /app
COPY --from=publish /app/publish .
ENTRYPOINT ["dotnet", "BlazorWebGame.Server.dll"]
```

#### Docker Compose配置
```yaml
# docker-compose.yml
version: '3.8'

services:
  blazorwebgame-server:
    build:
      context: .
      dockerfile: src/BlazorWebGame.Server/Dockerfile
    ports:
      - "7000:80"
      - "7001:443"
    environment:
      - ASPNETCORE_ENVIRONMENT=Production
      - ConnectionStrings__DefaultConnection=Server=db;Database=BlazorWebGame;User=sa;Password=YourStrong@Passw0rd
      - JwtSettings__SecretKey=YourSuperSecretKeyThatIsAtLeast32Characters
      - JwtSettings__Issuer=BlazorWebGame
      - JwtSettings__Audience=BlazorWebGameClient
    depends_on:
      - db
      - redis
    networks:
      - blazorwebgame-network

  blazorwebgame-client:
    build:
      context: .
      dockerfile: src/BlazorWebGame.Client/Dockerfile
    ports:
      - "8080:80"
    environment:
      - API_BASE_URL=http://blazorwebgame-server:80
    depends_on:
      - blazorwebgame-server
    networks:
      - blazorwebgame-network

  db:
    image: mcr.microsoft.com/mssql/server:2019-latest
    environment:
      - ACCEPT_EULA=Y
      - SA_PASSWORD=YourStrong@Passw0rd
    ports:
      - "1433:1433"
    volumes:
      - db_data:/var/opt/mssql
    networks:
      - blazorwebgame-network

  redis:
    image: redis:alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    networks:
      - blazorwebgame-network

volumes:
  db_data:
  redis_data:

networks:
  blazorwebgame-network:
    driver: bridge
```

### 4.2 CI/CD配置

#### GitHub Actions工作流
```yaml
# .github/workflows/deploy.yml
name: Deploy BlazorWebGame

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup .NET
      uses: actions/setup-dotnet@v3
      with:
        dotnet-version: 8.0.x
    
    - name: Restore dependencies
      run: dotnet restore
    
    - name: Build
      run: dotnet build --no-restore
    
    - name: Test
      run: dotnet test --no-build --verbosity normal

  build-and-deploy:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup Docker Buildx
      uses: docker/setup-buildx-action@v2
    
    - name: Login to Docker Hub
      uses: docker/login-action@v2
      with:
        username: ${{ secrets.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_PASSWORD }}
    
    - name: Build and push Server image
      uses: docker/build-push-action@v4
      with:
        context: .
        file: src/BlazorWebGame.Server/Dockerfile
        push: true
        tags: ${{ secrets.DOCKER_USERNAME }}/blazorwebgame-server:latest
    
    - name: Build and push Client image
      uses: docker/build-push-action@v4
      with:
        context: .
        file: src/BlazorWebGame.Client/Dockerfile
        push: true
        tags: ${{ secrets.DOCKER_USERNAME }}/blazorwebgame-client:latest
    
    - name: Deploy to production
      run: |
        # 部署脚本 - 根据实际部署环境调整
        echo "Deploying to production..."
```

## 总结

本技术实施指南提供了BlazorWebGame前后端分离优化的详细实现方案，涵盖状态管理、API标准化、认证授权和部署配置四个核心领域。通过逐步实施这些技术方案，可以将项目升级为现代化的前后端分离应用，提升系统的可维护性、安全性和用户体验。

建议按照以下顺序实施：
1. 首先实施状态管理系统，建立统一的数据流管理
2. 然后进行API标准化重构，提升接口的一致性和可维护性
3. 接着实施认证授权系统，加强应用安全性
4. 最后完善部署配置，实现自动化部署和运维

每个阶段都应该充分测试，确保功能正常后再进入下一阶段，以降低实施风险。