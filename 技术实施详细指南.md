# BlazorWebGame 技术实施详细指南

## 概述

本指南提供BlazorWebGame前后端分离优化的具体技术实施步骤，包括代码示例、配置方法和最佳实践。

## 第一阶段：技术债务清理

### 1.1 编译警告修复

#### CS8618 非空字段初始化问题修复
```csharp
// 修复前
public class GameApiService
{
    private readonly HttpClient _httpClient;
    private readonly ILogger<GameApiService> _logger;
    
    // 构造函数未初始化字段
}

// 修复后
public class GameApiService
{
    private readonly HttpClient _httpClient;
    private readonly ILogger<GameApiService> _logger;
    
    public GameApiService(HttpClient httpClient, ILogger<GameApiService> logger)
    {
        _httpClient = httpClient ?? throw new ArgumentNullException(nameof(httpClient));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }
}
```

#### CS1998 异步方法缺少await修复
```csharp
// 修复前
public async Task<bool> IsServerAvailableAsync()
{
    try
    {
        var response = _httpClient.GetAsync("api/health");
        return true;
    }
    catch
    {
        return false;
    }
}

// 修复后
public async Task<bool> IsServerAvailableAsync()
{
    try
    {
        var response = await _httpClient.GetAsync("api/health");
        return response.IsSuccessStatusCode;
    }
    catch
    {
        return false;
    }
}
```

### 1.2 代码重构标准化

#### 混合服务基类抽象
```csharp
public abstract class HybridServiceBase<TLocal, TRemote>
    where TLocal : class
    where TRemote : class
{
    protected readonly TLocal LocalService;
    protected readonly TRemote RemoteService;
    protected readonly IConnectivityService ConnectivityService;
    protected readonly ILogger Logger;

    protected HybridServiceBase(
        TLocal localService,
        TRemote remoteService,
        IConnectivityService connectivityService,
        ILogger logger)
    {
        LocalService = localService ?? throw new ArgumentNullException(nameof(localService));
        RemoteService = remoteService ?? throw new ArgumentNullException(nameof(remoteService));
        ConnectivityService = connectivityService ?? throw new ArgumentNullException(nameof(connectivityService));
        Logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    protected async Task<T> ExecuteHybridAsync<T>(
        Func<TLocal, Task<T>> localAction,
        Func<TRemote, Task<T>> remoteAction,
        bool preferRemote = true)
    {
        var isOnline = await ConnectivityService.IsOnlineAsync();
        
        if (preferRemote && isOnline)
        {
            try
            {
                return await remoteAction(RemoteService);
            }
            catch (Exception ex)
            {
                Logger.LogWarning(ex, "Remote service failed, falling back to local");
                return await localAction(LocalService);
            }
        }
        
        return await localAction(LocalService);
    }
}
```

## 第二阶段：状态管理重构

### 2.1 Redux模式状态管理实现

#### 状态定义
```csharp
// GameState.cs
public record GameState
{
    public PlayerState Player { get; init; } = new();
    public InventoryState Inventory { get; init; } = new();
    public BattleState Battle { get; init; } = new();
    public UIState UI { get; init; } = new();
    public ConnectionState Connection { get; init; } = new();
}

public record PlayerState
{
    public string Id { get; init; } = string.Empty;
    public string Name { get; init; } = string.Empty;
    public int Level { get; init; } = 1;
    public long Experience { get; init; } = 0;
    public int Health { get; init; } = 100;
    public int MaxHealth { get; init; } = 100;
    public int Mana { get; init; } = 50;
    public int MaxMana { get; init; } = 50;
    public Dictionary<string, int> Attributes { get; init; } = new();
    public PlayerActionState CurrentAction { get; init; } = PlayerActionState.Idle;
}

public record InventoryState
{
    public List<ItemStack> Items { get; init; } = new();
    public int Capacity { get; init; } = 50;
    public int UsedSlots { get; init; } = 0;
    public Dictionary<string, int> ItemCounts { get; init; } = new();
}
```

#### 动作定义
```csharp
// GameActions.cs
public abstract record GameAction
{
    public DateTime Timestamp { get; init; } = DateTime.UtcNow;
    public string ActionId { get; init; } = Guid.NewGuid().ToString();
}

// 玩家动作
public record UpdatePlayerHealth(int NewHealth, int MaxHealth) : GameAction;
public record UpdatePlayerLevel(int NewLevel, long Experience) : GameAction;
public record UpdatePlayerAction(PlayerActionState NewAction) : GameAction;

// 背包动作
public record AddInventoryItem(ItemStack Item) : GameAction;
public record RemoveInventoryItem(string ItemId, int Quantity) : GameAction;
public record UpdateInventoryItem(string ItemId, int NewQuantity) : GameAction;

// 战斗动作
public record StartBattle(string EnemyId, string? PartyId = null) : GameAction;
public record UpdateBattleState(BattleStateDto BattleState) : GameAction;
public record EndBattle(Guid BattleId, BattleResult Result) : GameAction;

// UI动作
public record ShowNotification(string Message, NotificationType Type) : GameAction;
public record UpdateLoadingState(bool IsLoading, string? Message = null) : GameAction;
public record ShowModal(string ModalName, object? Data = null) : GameAction;
```

#### 状态更新器实现
```csharp
// GameReducer.cs
public static class GameReducer
{
    public static GameState Reduce(GameState state, GameAction action)
    {
        return action switch
        {
            // 玩家状态更新
            UpdatePlayerHealth(var health, var maxHealth) => state with
            {
                Player = state.Player with { Health = health, MaxHealth = maxHealth }
            },
            
            UpdatePlayerLevel(var level, var exp) => state with
            {
                Player = state.Player with { Level = level, Experience = exp }
            },
            
            UpdatePlayerAction(var actionState) => state with
            {
                Player = state.Player with { CurrentAction = actionState }
            },
            
            // 背包状态更新
            AddInventoryItem(var item) => state with
            {
                Inventory = AddItemToInventory(state.Inventory, item)
            },
            
            RemoveInventoryItem(var itemId, var quantity) => state with
            {
                Inventory = RemoveItemFromInventory(state.Inventory, itemId, quantity)
            },
            
            // 战斗状态更新
            StartBattle(var enemyId, var partyId) => state with
            {
                Battle = state.Battle with
                {
                    IsActive = true,
                    EnemyId = enemyId,
                    PartyId = partyId,
                    StartTime = DateTime.UtcNow
                }
            },
            
            UpdateBattleState(var battleState) => state with
            {
                Battle = MapBattleStateDto(battleState)
            },
            
            // UI状态更新
            ShowNotification(var message, var type) => state with
            {
                UI = state.UI with
                {
                    Notifications = state.UI.Notifications.Add(new Notification
                    {
                        Id = Guid.NewGuid().ToString(),
                        Message = message,
                        Type = type,
                        Timestamp = DateTime.UtcNow
                    })
                }
            },
            
            _ => state
        };
    }
    
    private static InventoryState AddItemToInventory(InventoryState inventory, ItemStack item)
    {
        var existingItem = inventory.Items.FirstOrDefault(i => i.ItemId == item.ItemId);
        
        if (existingItem != null)
        {
            // 更新现有物品数量
            var updatedItems = inventory.Items.Select(i => 
                i.ItemId == item.ItemId 
                    ? i with { Quantity = i.Quantity + item.Quantity }
                    : i
            ).ToList();
            
            return inventory with
            {
                Items = updatedItems,
                ItemCounts = UpdateItemCounts(inventory.ItemCounts, item.ItemId, item.Quantity)
            };
        }
        else
        {
            // 添加新物品
            return inventory with
            {
                Items = inventory.Items.Add(item),
                UsedSlots = inventory.UsedSlots + 1,
                ItemCounts = UpdateItemCounts(inventory.ItemCounts, item.ItemId, item.Quantity)
            };
        }
    }
}
```

#### 状态存储服务
```csharp
// GameStore.cs
public class GameStore : IDisposable
{
    private GameState _state = new();
    private readonly List<IStateSubscriber> _subscribers = new();
    private readonly List<Func<GameState, GameAction, GameState>> _middlewares = new();
    private readonly ILogger<GameStore> _logger;
    private readonly SemaphoreSlim _stateLock = new(1, 1);

    public GameState State => _state;
    public event Action<GameState, GameAction>? StateChanged;

    public GameStore(ILogger<GameStore> logger)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        
        // 添加默认中间件
        AddMiddleware(LoggingMiddleware);
        AddMiddleware(PersistenceMiddleware);
    }

    public async Task DispatchAsync(GameAction action)
    {
        await _stateLock.WaitAsync();
        try
        {
            var previousState = _state;
            var newState = previousState;

            // 应用中间件
            foreach (var middleware in _middlewares)
            {
                newState = middleware(newState, action);
            }

            // 应用主要的状态更新
            newState = GameReducer.Reduce(newState, action);

            _state = newState;
            
            _logger.LogDebug("State updated: {ActionType}", action.GetType().Name);
            
            // 通知订阅者
            StateChanged?.Invoke(newState, action);
            await NotifySubscribersAsync(newState, action);
        }
        finally
        {
            _stateLock.Release();
        }
    }

    public void Subscribe(IStateSubscriber subscriber)
    {
        _subscribers.Add(subscriber);
    }

    public void Unsubscribe(IStateSubscriber subscriber)
    {
        _subscribers.Remove(subscriber);
    }

    public void AddMiddleware(Func<GameState, GameAction, GameState> middleware)
    {
        _middlewares.Add(middleware);
    }

    private GameState LoggingMiddleware(GameState state, GameAction action)
    {
        _logger.LogDebug("Processing action: {ActionType} at {Timestamp}", 
            action.GetType().Name, action.Timestamp);
        return state;
    }

    private GameState PersistenceMiddleware(GameState state, GameAction action)
    {
        // 异步保存关键状态变更
        if (ShouldPersist(action))
        {
            _ = Task.Run(async () => await PersistStateAsync(state));
        }
        return state;
    }

    private async Task NotifySubscribersAsync(GameState state, GameAction action)
    {
        var tasks = _subscribers.Select(subscriber => 
            Task.Run(() => subscriber.OnStateChanged(state, action)));
        
        await Task.WhenAll(tasks);
    }

    public void Dispose()
    {
        _stateLock?.Dispose();
        _subscribers.Clear();
        _middlewares.Clear();
    }
}
```

### 2.2 组件集成示例

#### Blazor组件状态集成
```csharp
// BattlePage.razor
@page "/battle"
@inherits GameStateComponent
@implements IStateSubscriber

<div class="battle-container">
    @if (State.Battle.IsActive)
    {
        <div class="battle-arena">
            <div class="player-section">
                <PlayerHealthBar Health="@State.Player.Health" MaxHealth="@State.Player.MaxHealth" />
                <PlayerActions OnAction="@HandlePlayerAction" />
            </div>
            
            <div class="enemy-section">
                <EnemyDisplay EnemyId="@State.Battle.EnemyId" />
            </div>
            
            <div class="battle-log">
                @foreach (var logEntry in State.Battle.BattleLog)
                {
                    <div class="log-entry">@logEntry</div>
                }
            </div>
        </div>
    }
    else
    {
        <div class="battle-selection">
            <EnemySelector OnEnemySelected="@StartBattle" />
        </div>
    }
</div>

@code {
    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();
        GameStore.Subscribe(this);
    }

    private async Task StartBattle(string enemyId)
    {
        await GameStore.DispatchAsync(new StartBattle(enemyId));
    }

    private async Task HandlePlayerAction(PlayerBattleAction action)
    {
        await GameStore.DispatchAsync(new ExecuteBattleAction(
            State.Battle.BattleId, 
            State.Player.Id, 
            action));
    }

    public Task OnStateChanged(GameState state, GameAction action)
    {
        if (action is UpdateBattleState)
        {
            InvokeAsync(StateHasChanged);
        }
        return Task.CompletedTask;
    }

    public override void Dispose()
    {
        GameStore.Unsubscribe(this);
        base.Dispose();
    }
}
```

#### 基础状态组件
```csharp
// GameStateComponent.cs
public abstract class GameStateComponent : ComponentBase, IDisposable
{
    [Inject] protected GameStore GameStore { get; set; } = null!;
    [Inject] protected ILogger Logger { get; set; } = null!;

    protected GameState State => GameStore.State;

    protected override void OnInitialized()
    {
        GameStore.StateChanged += OnGameStateChanged;
    }

    protected virtual void OnGameStateChanged(GameState state, GameAction action)
    {
        InvokeAsync(StateHasChanged);
    }

    protected async Task DispatchAsync(GameAction action)
    {
        try
        {
            await GameStore.DispatchAsync(action);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error dispatching action: {ActionType}", action.GetType().Name);
            
            // 显示错误通知
            await GameStore.DispatchAsync(new ShowNotification(
                "操作失败，请重试", 
                NotificationType.Error));
        }
    }

    public virtual void Dispose()
    {
        GameStore.StateChanged -= OnGameStateChanged;
    }
}
```

## 第三阶段：API标准化

### 3.1 RESTful API重设计

#### 统一响应格式
```csharp
// ApiResponse.cs
public class ApiResponse<T>
{
    public bool Success { get; set; }
    public string Message { get; set; } = string.Empty;
    public T? Data { get; set; }
    public List<string> Errors { get; set; } = new();
    public DateTime Timestamp { get; set; } = DateTime.UtcNow;
    public string? TraceId { get; set; }
    public PaginationInfo? Pagination { get; set; }

    public static ApiResponse<T> SuccessResult(T data, string message = "Success")
    {
        return new ApiResponse<T>
        {
            Success = true,
            Data = data,
            Message = message
        };
    }

    public static ApiResponse<T> ErrorResult(string message, List<string>? errors = null)
    {
        return new ApiResponse<T>
        {
            Success = false,
            Message = message,
            Errors = errors ?? new List<string> { message }
        };
    }
}

public class PaginationInfo
{
    public int Page { get; set; }
    public int PageSize { get; set; }
    public int TotalCount { get; set; }
    public int TotalPages { get; set; }
    public bool HasNext { get; set; }
    public bool HasPrevious { get; set; }
}
```

#### 控制器基类
```csharp
// BaseApiController.cs
[ApiController]
[Route("api/v1/[controller]")]
[Produces("application/json")]
public abstract class BaseApiController : ControllerBase
{
    protected readonly ILogger Logger;
    protected readonly IGameAuthenticationService AuthService;

    protected BaseApiController(ILogger logger, IGameAuthenticationService authService)
    {
        Logger = logger ?? throw new ArgumentNullException(nameof(logger));
        AuthService = authService ?? throw new ArgumentNullException(nameof(authService));
    }

    protected async Task<string> GetCurrentUserIdAsync()
    {
        var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
        if (string.IsNullOrEmpty(userId))
        {
            throw new UnauthorizedAccessException("User not authenticated");
        }
        return userId;
    }

    protected async Task<List<string>> GetUserCharacterIdsAsync()
    {
        var characterIds = User.FindFirst("character_ids")?.Value;
        if (string.IsNullOrEmpty(characterIds))
        {
            return new List<string>();
        }
        return characterIds.Split(',').ToList();
    }

    protected ActionResult<ApiResponse<T>> Success<T>(T data, string message = "Success")
    {
        return Ok(ApiResponse<T>.SuccessResult(data, message));
    }

    protected ActionResult<ApiResponse<T>> Error<T>(string message, List<string>? errors = null)
    {
        return BadRequest(ApiResponse<T>.ErrorResult(message, errors));
    }

    protected ActionResult<ApiResponse<T>> NotFound<T>(string message = "Resource not found")
    {
        return NotFound(ApiResponse<T>.ErrorResult(message));
    }
}
```

#### 标准化控制器示例
```csharp
// CharactersController.cs
[ApiController]
[Route("api/v1/[controller]")]
[Authorize]
public class CharactersController : BaseApiController
{
    private readonly ICharacterService _characterService;
    private readonly IMapper _mapper;

    public CharactersController(
        ICharacterService characterService,
        IMapper mapper,
        ILogger<CharactersController> logger,
        IGameAuthenticationService authService)
        : base(logger, authService)
    {
        _characterService = characterService ?? throw new ArgumentNullException(nameof(characterService));
        _mapper = mapper ?? throw new ArgumentNullException(nameof(mapper));
    }

    /// <summary>
    /// 获取当前用户的角色列表
    /// </summary>
    [HttpGet]
    [ProducesResponseType(typeof(ApiResponse<PagedResult<CharacterDto>>), 200)]
    public async Task<ActionResult<ApiResponse<PagedResult<CharacterDto>>>> GetCharacters(
        [FromQuery] CharacterFilter filter,
        [FromQuery] PaginationRequest pagination)
    {
        try
        {
            var userId = await GetCurrentUserIdAsync();
            filter.UserId = userId; // 确保只能查询自己的角色

            var characters = await _characterService.GetCharactersAsync(filter, pagination);
            var characterDtos = _mapper.Map<PagedResult<CharacterDto>>(characters);

            return Success(characterDtos, $"Found {characterDtos.TotalCount} characters");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error getting characters for user");
            return Error<PagedResult<CharacterDto>>("Failed to retrieve characters");
        }
    }

    /// <summary>
    /// 获取指定角色详情
    /// </summary>
    [HttpGet("{id:guid}")]
    [ProducesResponseType(typeof(ApiResponse<CharacterDetailDto>), 200)]
    [ProducesResponseType(typeof(ApiResponse<CharacterDetailDto>), 404)]
    public async Task<ActionResult<ApiResponse<CharacterDetailDto>>> GetCharacter(Guid id)
    {
        try
        {
            var characterIds = await GetUserCharacterIdsAsync();
            if (!characterIds.Contains(id.ToString()))
            {
                return NotFound<CharacterDetailDto>("Character not found or access denied");
            }

            var character = await _characterService.GetCharacterDetailAsync(id);
            if (character == null)
            {
                return NotFound<CharacterDetailDto>("Character not found");
            }

            var characterDto = _mapper.Map<CharacterDetailDto>(character);
            return Success(characterDto, "Character retrieved successfully");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error getting character {CharacterId}", id);
            return Error<CharacterDetailDto>("Failed to retrieve character");
        }
    }

    /// <summary>
    /// 创建新角色
    /// </summary>
    [HttpPost]
    [ProducesResponseType(typeof(ApiResponse<CharacterDto>), 201)]
    [ProducesResponseType(typeof(ApiResponse<CharacterDto>), 400)]
    public async Task<ActionResult<ApiResponse<CharacterDto>>> CreateCharacter(
        [FromBody] CreateCharacterRequest request)
    {
        try
        {
            if (!ModelState.IsValid)
            {
                var errors = ModelState.Values
                    .SelectMany(v => v.Errors)
                    .Select(e => e.ErrorMessage)
                    .ToList();
                return Error<CharacterDto>("Invalid request data", errors);
            }

            var userId = await GetCurrentUserIdAsync();
            var character = await _characterService.CreateCharacterAsync(userId, request);
            var characterDto = _mapper.Map<CharacterDto>(character);

            return CreatedAtAction(
                nameof(GetCharacter),
                new { id = character.Id },
                ApiResponse<CharacterDto>.SuccessResult(characterDto, "Character created successfully"));
        }
        catch (ArgumentException ex)
        {
            return Error<CharacterDto>(ex.Message);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error creating character for user");
            return Error<CharacterDto>("Failed to create character");
        }
    }

    /// <summary>
    /// 更新角色信息
    /// </summary>
    [HttpPut("{id:guid}")]
    [ProducesResponseType(typeof(ApiResponse<CharacterDto>), 200)]
    [ProducesResponseType(typeof(ApiResponse<CharacterDto>), 404)]
    public async Task<ActionResult<ApiResponse<CharacterDto>>> UpdateCharacter(
        Guid id,
        [FromBody] UpdateCharacterRequest request)
    {
        try
        {
            var characterIds = await GetUserCharacterIdsAsync();
            if (!characterIds.Contains(id.ToString()))
            {
                return NotFound<CharacterDto>("Character not found or access denied");
            }

            var character = await _characterService.UpdateCharacterAsync(id, request);
            if (character == null)
            {
                return NotFound<CharacterDto>("Character not found");
            }

            var characterDto = _mapper.Map<CharacterDto>(character);
            return Success(characterDto, "Character updated successfully");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error updating character {CharacterId}", id);
            return Error<CharacterDto>("Failed to update character");
        }
    }

    /// <summary>
    /// 删除角色
    /// </summary>
    [HttpDelete("{id:guid}")]
    [ProducesResponseType(typeof(ApiResponse<bool>), 200)]
    [ProducesResponseType(typeof(ApiResponse<bool>), 404)]
    public async Task<ActionResult<ApiResponse<bool>>> DeleteCharacter(Guid id)
    {
        try
        {
            var characterIds = await GetUserCharacterIdsAsync();
            if (!characterIds.Contains(id.ToString()))
            {
                return NotFound<bool>("Character not found or access denied");
            }

            var success = await _characterService.DeleteCharacterAsync(id);
            if (!success)
            {
                return NotFound<bool>("Character not found");
            }

            return Success(true, "Character deleted successfully");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error deleting character {CharacterId}", id);
            return Error<bool>("Failed to delete character");
        }
    }
}
```

### 3.2 GraphQL API实现

#### GraphQL Schema定义
```csharp
// GraphQL/Types/CharacterType.cs
public class CharacterType : ObjectGraphType<Character>
{
    public CharacterType()
    {
        Name = "Character";
        Description = "A game character";

        Field(x => x.Id, type: typeof(IdGraphType)).Description("The character's unique identifier");
        Field(x => x.Name).Description("The character's name");
        Field(x => x.Level).Description("The character's level");
        Field(x => x.Experience).Description("The character's experience points");
        Field(x => x.Health).Description("The character's current health");
        Field(x => x.MaxHealth).Description("The character's maximum health");
        
        Field<InventoryType>("inventory")
            .Description("The character's inventory")
            .ResolveAsync(async context =>
            {
                var inventoryService = context.RequestServices.GetRequiredService<IInventoryService>();
                return await inventoryService.GetInventoryAsync(context.Source.Id);
            });

        Field<ListGraphType<BattleType>>("battles")
            .Description("The character's battle history")
            .Argument<IntGraphType>("limit", "Maximum number of battles to return")
            .ResolveAsync(async context =>
            {
                var battleService = context.RequestServices.GetRequiredService<IBattleService>();
                var limit = context.GetArgument<int?>("limit") ?? 10;
                return await battleService.GetCharacterBattlesAsync(context.Source.Id, limit);
            });
    }
}
```

#### GraphQL查询和变更
```csharp
// GraphQL/GameQuery.cs
public class GameQuery : ObjectGraphType
{
    public GameQuery()
    {
        Field<CharacterType>("character")
            .Description("Get a character by ID")
            .Argument<NonNullGraphType<IdGraphType>>("id", "The character's ID")
            .ResolveAsync(async context =>
            {
                var id = context.GetArgument<Guid>("id");
                var characterService = context.RequestServices.GetRequiredService<ICharacterService>();
                return await characterService.GetCharacterAsync(id);
            });

        Field<ListGraphType<CharacterType>>("characters")
            .Description("Get characters with optional filtering")
            .Argument<CharacterFilterInputType>("filter", "Filter criteria")
            .Argument<PaginationInputType>("pagination", "Pagination settings")
            .ResolveAsync(async context =>
            {
                var filter = context.GetArgument<CharacterFilter>("filter") ?? new CharacterFilter();
                var pagination = context.GetArgument<PaginationRequest>("pagination") ?? new PaginationRequest();
                var characterService = context.RequestServices.GetRequiredService<ICharacterService>();
                return await characterService.GetCharactersAsync(filter, pagination);
            });
    }
}

// GraphQL/GameMutation.cs
public class GameMutation : ObjectGraphType
{
    public GameMutation()
    {
        Field<CharacterType>("createCharacter")
            .Description("Create a new character")
            .Argument<NonNullGraphType<CreateCharacterInputType>>("input", "Character creation data")
            .ResolveAsync(async context =>
            {
                var input = context.GetArgument<CreateCharacterRequest>("input");
                var characterService = context.RequestServices.GetRequiredService<ICharacterService>();
                var userId = context.User?.FindFirst(ClaimTypes.NameIdentifier)?.Value;
                
                if (string.IsNullOrEmpty(userId))
                    throw new UnauthorizedAccessException("User not authenticated");
                
                return await characterService.CreateCharacterAsync(userId, input);
            });

        Field<BattleType>("startBattle")
            .Description("Start a new battle")
            .Argument<NonNullGraphType<StartBattleInputType>>("input", "Battle start data")
            .ResolveAsync(async context =>
            {
                var input = context.GetArgument<StartBattleRequest>("input");
                var battleService = context.RequestServices.GetRequiredService<IBattleService>();
                return await battleService.StartBattleAsync(input);
            });
    }
}
```

#### GraphQL订阅
```csharp
// GraphQL/GameSubscription.cs
public class GameSubscription : ObjectGraphType
{
    public GameSubscription()
    {
        AddField(new EventStreamFieldType
        {
            Name = "characterUpdates",
            Type = typeof(CharacterType),
            Arguments = new QueryArguments(
                new QueryArgument<NonNullGraphType<IdGraphType>> { Name = "characterId" }
            ),
            Resolver = new FuncFieldResolver<Character>(context => 
                context.Source as Character),
            Subscriber = new EventStreamResolver<Character>(context =>
            {
                var characterId = context.GetArgument<Guid>("characterId");
                var eventService = context.RequestServices.GetRequiredService<IEventService>();
                return eventService.GetCharacterUpdates(characterId);
            })
        });

        AddField(new EventStreamFieldType
        {
            Name = "battleUpdates",
            Type = typeof(BattleType),
            Arguments = new QueryArguments(
                new QueryArgument<NonNullGraphType<IdGraphType>> { Name = "battleId" }
            ),
            Resolver = new FuncFieldResolver<Battle>(context => 
                context.Source as Battle),
            Subscriber = new EventStreamResolver<Battle>(context =>
            {
                var battleId = context.GetArgument<Guid>("battleId");
                var eventService = context.RequestServices.GetRequiredService<IEventService>();
                return eventService.GetBattleUpdates(battleId);
            })
        });
    }
}
```

## 第四阶段：业务逻辑迁移

### 4.1 战斗系统服务端化

#### 服务端战斗引擎
```csharp
// Services/BattleEngineService.cs
public class BattleEngineService : IBattleEngineService
{
    private readonly Dictionary<Guid, BattleInstance> _activeBattles = new();
    private readonly ILogger<BattleEngineService> _logger;
    private readonly ICharacterService _characterService;
    private readonly IGameHub _gameHub;
    private readonly Timer _battleTimer;

    public BattleEngineService(
        ILogger<BattleEngineService> logger,
        ICharacterService characterService,
        IGameHub gameHub)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        _characterService = characterService ?? throw new ArgumentNullException(nameof(characterService));
        _gameHub = gameHub ?? throw new ArgumentNullException(nameof(gameHub));
        
        // 每500ms处理一次战斗更新
        _battleTimer = new Timer(ProcessBattleTick, null, TimeSpan.Zero, TimeSpan.FromMilliseconds(500));
    }

    public async Task<Battle> StartBattleAsync(StartBattleRequest request)
    {
        var battle = new Battle
        {
            Id = Guid.NewGuid(),
            CharacterId = request.CharacterId,
            EnemyId = request.EnemyId,
            PartyId = request.PartyId,
            StartTime = DateTime.UtcNow,
            Status = BattleStatus.Active
        };

        // 加载角色和敌人数据
        var character = await _characterService.GetCharacterAsync(Guid.Parse(request.CharacterId));
        var enemy = await LoadEnemyAsync(request.EnemyId);
        
        var battleInstance = new BattleInstance
        {
            Battle = battle,
            PlayerParticipants = new List<BattleParticipant> { CreateBattleParticipant(character) },
            EnemyParticipants = new List<BattleParticipant> { CreateBattleParticipant(enemy) },
            LastTickTime = DateTime.UtcNow
        };

        _activeBattles[battle.Id] = battleInstance;
        
        _logger.LogInformation("Battle {BattleId} started between {CharacterId} and {EnemyId}", 
            battle.Id, request.CharacterId, request.EnemyId);

        // 通知客户端
        await _gameHub.NotifyBattleStarted(battle);
        
        return battle;
    }

    public async Task<BattleActionResult> ExecuteActionAsync(BattleActionRequest request)
    {
        if (!_activeBattles.TryGetValue(request.BattleId, out var battleInstance))
        {
            throw new InvalidOperationException("Battle not found");
        }

        var participant = battleInstance.PlayerParticipants
            .FirstOrDefault(p => p.Id == request.PlayerId);
            
        if (participant == null)
        {
            throw new InvalidOperationException("Player not in battle");
        }

        // 验证动作是否有效
        var validationResult = await ValidateActionAsync(participant, request.Action);
        if (!validationResult.IsValid)
        {
            return BattleActionResult.Failed(validationResult.ErrorMessage);
        }

        // 执行动作
        var result = await ExecuteBattleActionAsync(battleInstance, participant, request.Action);
        
        // 更新战斗状态
        battleInstance.LastActionTime = DateTime.UtcNow;
        battleInstance.ActionHistory.Add(result);

        // 通知客户端
        await _gameHub.NotifyBattleAction(request.BattleId, result);

        // 检查战斗是否结束
        if (IsBattleFinished(battleInstance))
        {
            await EndBattleAsync(battleInstance);
        }

        return result;
    }

    private async void ProcessBattleTick(object? state)
    {
        var battleIds = _activeBattles.Keys.ToList();
        
        foreach (var battleId in battleIds)
        {
            if (_activeBattles.TryGetValue(battleId, out var battleInstance))
            {
                try
                {
                    await ProcessBattleInstanceTick(battleInstance);
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Error processing battle tick for {BattleId}", battleId);
                }
            }
        }
    }

    private async Task ProcessBattleInstanceTick(BattleInstance battleInstance)
    {
        var deltaTime = DateTime.UtcNow - battleInstance.LastTickTime;
        battleInstance.LastTickTime = DateTime.UtcNow;

        // 处理持续效果
        await ProcessContinuousEffects(battleInstance, deltaTime);
        
        // 处理AI行为
        await ProcessAIActions(battleInstance);
        
        // 处理冷却时间
        ProcessCooldowns(battleInstance, deltaTime);
        
        // 检查战斗超时
        if (DateTime.UtcNow - battleInstance.Battle.StartTime > TimeSpan.FromMinutes(30))
        {
            await EndBattleAsync(battleInstance, BattleEndReason.Timeout);
        }
    }

    private async Task<BattleActionResult> ExecuteBattleActionAsync(
        BattleInstance battleInstance, 
        BattleParticipant actor, 
        BattleAction action)
    {
        return action.Type switch
        {
            BattleActionType.Attack => await ExecuteAttackAsync(battleInstance, actor, action),
            BattleActionType.UseSkill => await ExecuteSkillAsync(battleInstance, actor, action),
            BattleActionType.UseItem => await ExecuteItemUseAsync(battleInstance, actor, action),
            BattleActionType.Defend => await ExecuteDefendAsync(battleInstance, actor, action),
            _ => throw new InvalidOperationException($"Unknown action type: {action.Type}")
        };
    }

    private async Task<BattleActionResult> ExecuteAttackAsync(
        BattleInstance battleInstance, 
        BattleParticipant attacker, 
        BattleAction action)
    {
        var target = FindTarget(battleInstance, action.TargetId);
        if (target == null)
        {
            return BattleActionResult.Failed("Target not found");
        }

        // 计算伤害
        var damage = CalculateDamage(attacker, target, action);
        
        // 应用伤害
        target.Health = Math.Max(0, target.Health - damage);
        
        // 设置攻击冷却
        attacker.AttackCooldown = DateTime.UtcNow.AddSeconds(attacker.AttacksPerSecond > 0 
            ? 1.0 / attacker.AttacksPerSecond 
            : 1.0);

        var result = new BattleActionResult
        {
            Success = true,
            ActorId = attacker.Id,
            TargetId = target.Id,
            ActionType = BattleActionType.Attack,
            Damage = damage,
            TargetHealthAfter = target.Health,
            Timestamp = DateTime.UtcNow
        };

        _logger.LogDebug("Attack executed: {AttackerId} -> {TargetId}, Damage: {Damage}", 
            attacker.Id, target.Id, damage);

        return result;
    }

    private int CalculateDamage(BattleParticipant attacker, BattleParticipant target, BattleAction action)
    {
        // 基础伤害计算
        var baseDamage = attacker.AttackPower;
        
        // 随机因子 (80% - 120%)
        var randomFactor = Random.Shared.NextDouble() * 0.4 + 0.8;
        
        // 防御计算
        var defense = target.Defense;
        var damageReduction = defense / (defense + 100.0); // 简化的防御公式
        
        // 最终伤害
        var finalDamage = (int)(baseDamage * randomFactor * (1 - damageReduction));
        
        return Math.Max(1, finalDamage); // 至少造成1点伤害
    }
}
```

### 4.2 物品系统服务端化

#### 服务端物品生成服务
```csharp
// Services/ItemGenerationService.cs
public class ItemGenerationService : IItemGenerationService
{
    private readonly ILogger<ItemGenerationService> _logger;
    private readonly IItemTemplateService _itemTemplateService;
    private readonly Dictionary<string, DropTable> _dropTables;
    private readonly Random _random = new();

    public ItemGenerationService(
        ILogger<ItemGenerationService> logger,
        IItemTemplateService itemTemplateService)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        _itemTemplateService = itemTemplateService ?? throw new ArgumentNullException(nameof(itemTemplateService));
        _dropTables = LoadDropTables();
    }

    public async Task<List<ItemDrop>> GenerateDropsAsync(string sourceId, int playerLevel)
    {
        if (!_dropTables.TryGetValue(sourceId, out var dropTable))
        {
            return new List<ItemDrop>();
        }

        var drops = new List<ItemDrop>();

        foreach (var dropEntry in dropTable.Entries)
        {
            if (_random.NextDouble() <= dropEntry.DropRate)
            {
                var item = await GenerateItemAsync(dropEntry, playerLevel);
                if (item != null)
                {
                    drops.Add(new ItemDrop
                    {
                        Item = item,
                        Quantity = GenerateQuantity(dropEntry),
                        Source = sourceId
                    });
                }
            }
        }

        _logger.LogDebug("Generated {DropCount} items from {SourceId} for level {PlayerLevel}", 
            drops.Count, sourceId, playerLevel);

        return drops;
    }

    public async Task<GameItem?> GenerateItemAsync(string itemId, int itemLevel, ItemRarity? forcedRarity = null)
    {
        var template = await _itemTemplateService.GetItemTemplateAsync(itemId);
        if (template == null)
        {
            _logger.LogWarning("Item template not found: {ItemId}", itemId);
            return null;
        }

        var rarity = forcedRarity ?? DetermineItemRarity(template, itemLevel);
        var item = new GameItem
        {
            Id = Guid.NewGuid().ToString(),
            TemplateId = itemId,
            Name = template.Name,
            Description = template.Description,
            Type = template.Type,
            Rarity = rarity,
            Level = itemLevel,
            Properties = GenerateItemProperties(template, rarity, itemLevel),
            CreatedAt = DateTime.UtcNow
        };

        // 应用稀有度修饰符
        ApplyRarityModifiers(item, rarity);

        return item;
    }

    private ItemRarity DetermineItemRarity(ItemTemplate template, int itemLevel)
    {
        // 基础稀有度概率
        var rarityWeights = new Dictionary<ItemRarity, double>
        {
            [ItemRarity.Common] = 60.0,
            [ItemRarity.Uncommon] = 25.0,
            [ItemRarity.Rare] = 10.0,
            [ItemRarity.Epic] = 4.0,
            [ItemRarity.Legendary] = 1.0
        };

        // 等级影响稀有度
        var levelBonus = Math.Min(itemLevel / 10.0, 5.0);
        rarityWeights[ItemRarity.Rare] += levelBonus;
        rarityWeights[ItemRarity.Epic] += levelBonus / 2.0;
        rarityWeights[ItemRarity.Legendary] += levelBonus / 5.0;

        // 加权随机选择
        var totalWeight = rarityWeights.Values.Sum();
        var randomValue = _random.NextDouble() * totalWeight;
        var currentWeight = 0.0;

        foreach (var kvp in rarityWeights)
        {
            currentWeight += kvp.Value;
            if (randomValue <= currentWeight)
            {
                return kvp.Key;
            }
        }

        return ItemRarity.Common;
    }

    private Dictionary<string, object> GenerateItemProperties(
        ItemTemplate template, 
        ItemRarity rarity, 
        int itemLevel)
    {
        var properties = new Dictionary<string, object>();

        // 复制基础属性
        foreach (var baseProperty in template.BaseProperties)
        {
            properties[baseProperty.Key] = baseProperty.Value;
        }

        // 等级缩放
        ApplyLevelScaling(properties, itemLevel, template.LevelScaling);

        // 稀有度加成
        ApplyRarityBonuses(properties, rarity);

        // 随机变异
        ApplyRandomVariation(properties, template.VariationRanges);

        return properties;
    }

    private void ApplyRarityModifiers(GameItem item, ItemRarity rarity)
    {
        var modifier = rarity switch
        {
            ItemRarity.Common => 1.0,
            ItemRarity.Uncommon => 1.1,
            ItemRarity.Rare => 1.25,
            ItemRarity.Epic => 1.5,
            ItemRarity.Legendary => 2.0,
            _ => 1.0
        };

        // 应用属性加成
        var numericProperties = item.Properties
            .Where(p => p.Value is int or double or float)
            .ToList();

        foreach (var property in numericProperties)
        {
            if (property.Value is int intValue)
            {
                item.Properties[property.Key] = (int)(intValue * modifier);
            }
            else if (property.Value is double doubleValue)
            {
                item.Properties[property.Key] = doubleValue * modifier;
            }
            else if (property.Value is float floatValue)
            {
                item.Properties[property.Key] = (float)(floatValue * modifier);
            }
        }

        // 添加稀有度特有属性
        AddRaritySpecificProperties(item, rarity);
    }
}
```

### 4.3 经验和等级系统

#### 服务端经验计算服务
```csharp
// Services/ExperienceService.cs
public class ExperienceService : IExperienceService
{
    private readonly ILogger<ExperienceService> _logger;
    private readonly ICharacterService _characterService;
    private readonly Dictionary<int, ExperienceCurve> _experienceCurves;

    public ExperienceService(
        ILogger<ExperienceService> logger,
        ICharacterService characterService)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        _characterService = characterService ?? throw new ArgumentNullException(nameof(characterService));
        _experienceCurves = LoadExperienceCurves();
    }

    public async Task<ExperienceGainResult> GrantExperienceAsync(
        string characterId, 
        int experienceAmount, 
        ExperienceSource source)
    {
        var character = await _characterService.GetCharacterAsync(Guid.Parse(characterId));
        if (character == null)
        {
            throw new ArgumentException("Character not found", nameof(characterId));
        }

        var result = new ExperienceGainResult
        {
            CharacterId = characterId,
            OriginalLevel = character.Level,
            OriginalExperience = character.Experience,
            ExperienceGained = experienceAmount,
            Source = source
        };

        // 应用经验加成
        var bonusMultiplier = CalculateExperienceBonus(character, source);
        var actualExperience = (int)(experienceAmount * bonusMultiplier);
        result.ActualExperienceGained = actualExperience;

        // 更新经验值
        character.Experience += actualExperience;

        // 检查等级提升
        var levelUps = CheckLevelUp(character);
        if (levelUps > 0)
        {
            await ProcessLevelUp(character, levelUps);
            result.NewLevel = character.Level;
            result.LevelsGained = levelUps;
            result.AttributePointsGained = levelUps * GetAttributePointsPerLevel(character.Class);
            result.SkillPointsGained = levelUps * GetSkillPointsPerLevel(character.Class);
        }

        result.NewExperience = character.Experience;

        // 保存角色数据
        await _characterService.UpdateCharacterAsync(character);

        _logger.LogInformation(
            "Character {CharacterId} gained {Experience} experience from {Source}, " +
            "now level {Level} with {TotalExperience} total experience",
            characterId, actualExperience, source, character.Level, character.Experience);

        return result;
    }

    private int CheckLevelUp(Character character)
    {
        var levelsGained = 0;
        var currentLevel = character.Level;

        while (currentLevel < MaxLevel && 
               character.Experience >= GetExperienceRequiredForLevel(currentLevel + 1))
        {
            currentLevel++;
            levelsGained++;
        }

        return levelsGained;
    }

    private async Task ProcessLevelUp(Character character, int levelsGained)
    {
        var oldLevel = character.Level;
        character.Level += levelsGained;

        // 计算属性提升
        var attributeGains = CalculateAttributeGains(character, levelsGained);
        foreach (var gain in attributeGains)
        {
            character.Attributes[gain.Key] = character.Attributes.GetValueOrDefault(gain.Key, 0) + gain.Value;
        }

        // 恢复生命值和法力值
        character.Health = character.MaxHealth;
        character.Mana = character.MaxMana;

        // 解锁新技能
        var unlockedSkills = await UnlockSkillsForLevel(character, character.Level);

        _logger.LogInformation(
            "Character {CharacterId} leveled up from {OldLevel} to {NewLevel}, " +
            "gained {AttributePoints} attribute points and unlocked {SkillCount} skills",
            character.Id, oldLevel, character.Level, 
            attributeGains.Values.Sum(), unlockedSkills.Count);
    }

    private long GetExperienceRequiredForLevel(int level)
    {
        if (level <= 1) return 0;
        
        // 指数增长的经验曲线
        return (long)(100 * Math.Pow(level - 1, 2.2));
    }

    private double CalculateExperienceBonus(Character character, ExperienceSource source)
    {
        var bonus = 1.0;

        // 休息经验加成
        if (character.RestBonus > 0)
        {
            bonus += 0.5; // 50%加成
            character.RestBonus = Math.Max(0, character.RestBonus - 1);
        }

        // 组队加成
        if (source == ExperienceSource.PartyBattle)
        {
            bonus += 0.2; // 20%组队加成
        }

        // 等级差异调整
        var levelDifference = CalculateLevelDifference(character, source);
        bonus *= GetLevelDifferenceMultiplier(levelDifference);

        return bonus;
    }

    private Dictionary<string, int> CalculateAttributeGains(Character character, int levelsGained)
    {
        var gains = new Dictionary<string, int>();
        var baseGains = GetBaseAttributeGainsPerLevel(character.Class);

        foreach (var baseGain in baseGains)
        {
            gains[baseGain.Key] = baseGain.Value * levelsGained;
        }

        return gains;
    }
}
```

## 总结

本技术实施指南提供了BlazorWebGame前后端分离优化的详细实施步骤和代码示例。通过分阶段实施，可以安全地将现有混合架构升级为现代化的前后端分离架构，同时保持系统的稳定性和用户体验。

关键实施要点：
1. 渐进式迁移，避免大爆炸式重构
2. 建立完善的测试和监控体系
3. 优先解决技术债务，建立健康的代码基础
4. 注重性能和安全性的平衡
5. 持续关注用户体验和业务价值

通过遵循本指南的实施步骤，BlazorWebGame将成为技术先进、架构清晰的现代化Web游戏平台。
