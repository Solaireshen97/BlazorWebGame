# BlazorWebGame 客户端功能与接口说明文档

## 项目概述

BlazorWebGame 是一个基于 Blazor WebAssembly 的多人在线网页游戏，采用前后端分离架构，支持本地离线模式和服务器在线模式的无缝切换。

### 技术架构
- **前端框架**: Blazor WebAssembly 8.0
- **后端框架**: ASP.NET Core Web API 8.0
- **实时通信**: SignalR
- **本地存储**: LocalStorage/IndexedDB
- **状态管理**: 统一事件系统 + 混合服务架构

## 一、客户端核心功能模块

### 1.1 游戏页面功能 (19个页面)

#### 战斗系统
- **页面**: `Battle.razor`
- **功能特性**:
  - ✅ 支持本地/服务器双模式切换
  - ✅ 实时战斗状态同步
  - ✅ 组队战斗支持
  - ✅ 地下城探索
  - ✅ PvP战斗模式
  - ✅ 战斗动画和特效
  - ✅ 离线战斗记录

#### 采集生产系统
- **页面**: 
  - `Gathering.razor` (草药学采集)
  - `Mining.razor` (矿物采集)
  - `Fishing.razor` (钓鱼系统)
- **功能特性**:
  - ✅ 渐进式采集进度计算
  - ✅ 技能等级和熟练度系统
  - ✅ 快捷栏物品管理
  - ✅ 自动化采集支持
  - ✅ 资源点刷新机制

#### 生产制造系统
- **页面**: 
  - `Cooking.razor` (烹饪)
  - `Alchemy.razor` (炼金术)
  - `Blacksmithing.razor` (锻造)
  - `Jewelcrafting.razor` (珠宝加工)
  - `Leatherworking.razor` (制皮)
  - `Tailoring.razor` (裁缝)
  - `Engineering.razor` (工程学)
- **功能特性**:
  - ✅ 配方解锁和管理
  - ✅ 材料消耗计算
  - ✅ 批量制作功能
  - ✅ 品质随机系统
  - ✅ 制作进度可视化

#### 角色管理系统
- **页面**:
  - `Professions.razor` (职业技能树)
  - `CharacterStates.razor` (角色状态监控)
  - `Backpack.razor` (背包系统)
- **功能特性**:
  - ✅ 角色属性实时计算
  - ✅ 装备效果叠加
  - ✅ 技能点分配和重置
  - ✅ 库存物品分类管理
  - ✅ 拖拽操作支持

#### 商业交易系统
- **页面**:
  - `Shop.razor` (商店交易)
  - `Reputation.razor` (声望系统)
- **功能特性**:
  - ✅ 物品买卖交易
  - ✅ 价格波动系统
  - ✅ 声望值影响折扣
  - ✅ 限时特价商品

#### 开发调试页面
- **页面**:
  - `ApiTest.razor` (新API服务测试)
  - `ServerIntegrationTest.razor` (服务器集成测试)
  - `ServerTestInterface.razor` (服务端接口测试)
- **功能特性**:
  - ✅ API接口实时测试
  - ✅ 服务器连接状态监控
  - ✅ 数据同步验证工具

### 1.2 布局组件系统

#### 主布局 (`MainLayout.razor`)
- **导航菜单**: 19个功能页面的导航入口
- **玩家状态栏**: 实时显示角色信息
- **响应式设计**: 支持不同屏幕尺寸

#### 共享组件 (Shared目录)
- **装备展示**: `EquipmentSlotDisplay.razor`
- **技能卡片**: `SkillCard.razor`
- **职业组件**: 
  - `QuickSlotBar.razor` (快捷栏)
  - `NodeCard.razor` (技能节点)
  - `ActionProgressCard.razor` (进度显示)

## 二、客户端服务架构

### 2.1 API服务层 (25个API服务)

#### 统一API客户端
- **核心类**: `GameApiClient`
- **功能**: 提供对所有API服务的统一访问入口
- **组件**:
  - `BattleApiService` - 战斗API
  - `CharacterApiService` - 角色API
  - `PartyApiService` - 组队API
  - `InventoryApiService` - 库存API
  - `EquipmentApiService` - 装备API
  - `ProductionApiServiceNew` - 生产API
  - `QuestApiService` - 任务API
  - `AuthApiService` - 认证API
  - `OfflineSettlementApiService` - 离线结算API
  - `MonitoringApiService` - 监控API

#### 基础服务
- **BaseApiService**: API服务基类，提供通用HTTP请求功能
- **ConfigurableHttpClientFactory**: 可配置的HTTP客户端工厂
- **ServerConfigurationService**: 服务器配置管理

#### 特殊功能服务
- **OfflineService**: 离线模式管理
- **ClientGameStateService**: 客户端游戏状态管理
- **GameStorage**: 本地数据持久化

### 2.2 混合服务架构

#### 设计理念
混合服务架构允许应用在本地模式和服务器模式之间无缝切换，确保在网络不稳定或服务器不可用时，游戏仍能正常运行。

#### 核心混合服务
| 服务名称 | 本地实现 | 远程实现 | 功能描述 |
|---------|---------|---------|---------|
| `HybridCharacterService` | `CharacterService` | `ServerCharacterApiService` | 角色数据管理 |
| `HybridInventoryService` | `InventoryService` | `ClientInventoryApiService` | 库存物品管理 |
| `HybridProductionService` | `ProfessionService` | `ProductionApiService` | 生产制造管理 |
| `HybridQuestService` | `QuestService` | `ClientQuestApiService` | 任务系统管理 |
| `HybridEventService` | `EventManager` | `ServerEventService` | 事件系统管理 |
| `HybridShopService` | `ShopService` | `ShopApiService` | 商店交易管理 |

#### 切换机制
- **自动检测**: 自动检测服务器可用性
- **手动切换**: 支持用户手动切换模式
- **数据同步**: 模式切换时自动同步数据
- **离线缓存**: 离线操作记录和延迟同步

### 2.3 业务逻辑服务

#### 核心业务服务
- **GameStateService**: 主游戏状态管理
- **CombatService**: 战斗逻辑处理
- **InventoryService**: 库存管理逻辑
- **ProfessionService**: 职业技能管理
- **PartyService**: 组队系统逻辑
- **QuestService**: 任务系统逻辑

#### 专用服务
- **PlayerAttributeService**: 玩家属性计算
- **PlayerProfessionService**: 玩家职业管理
- **PlayerUtilityService**: 玩家工具函数

## 三、API接口规格说明

### 3.1 HTTP API接口

#### 战斗系统API
```typescript
// 开始战斗
POST /api/battle/start
Request: StartBattleRequest {
  characterId: string
  enemyId: string
  partyId?: string
}
Response: ApiResponse<BattleStateDto>

// 获取战斗状态
GET /api/battle/state/{battleId}
Response: ApiResponse<BattleStateDto>

// 停止战斗
POST /api/battle/stop/{battleId}
Response: ApiResponse<boolean>
```

#### 角色管理API
```typescript
// 获取角色列表
GET /api/character
Response: ApiResponse<CharacterDto[]>

// 获取角色详情
GET /api/character/{characterId}
Response: ApiResponse<CharacterDto>

// 创建角色
POST /api/character
Request: CreateCharacterRequest
Response: ApiResponse<CharacterDto>

// 更新角色
PUT /api/character/{characterId}
Request: UpdateCharacterRequest
Response: ApiResponse<CharacterDto>
```

#### 库存管理API
```typescript
// 获取库存
GET /api/inventory/{characterId}
Response: ApiResponse<InventoryDto>

// 添加物品
POST /api/inventory/add
Request: AddItemRequest
Response: ApiResponse<boolean>

// 移除物品
POST /api/inventory/remove
Request: RemoveItemRequest
Response: ApiResponse<boolean>

// 使用物品
POST /api/inventory/use
Request: UseItemRequest
Response: ApiResponse<UseItemResult>
```

#### 生产制造API
```typescript
// 开始生产
POST /api/production/start
Request: StartProductionRequest
Response: ApiResponse<ProductionStateDto>

// 获取生产状态
GET /api/production/state/{productionId}
Response: ApiResponse<ProductionStateDto>

// 完成生产
POST /api/production/complete/{productionId}
Response: ApiResponse<ProductionResultDto>
```

### 3.2 SignalR实时通信

#### GameHub连接
```typescript
// 连接地址
wss://localhost:7000/gamehub

// 监听事件
hubConnection.on("BattleUpdate", (battleState: BattleStateDto) => {
  // 处理战斗状态更新
});

hubConnection.on("InventoryUpdate", (inventory: InventoryDto) => {
  // 处理库存更新
});

hubConnection.on("PartyUpdate", (party: PartyDto) => {
  // 处理组队更新
});
```

### 3.3 数据传输对象 (DTOs)

#### 核心DTO定义
```typescript
// API响应基类
interface ApiResponse<T> {
  success: boolean;
  message: string;
  data?: T;
  errors: string[];
  timestamp: Date;
}

// 战斗状态DTO
interface BattleStateDto {
  battleId: string;
  characterId: string;
  enemyId: string;
  partyId?: string;
  isActive: boolean;
  playerHealth: number;
  playerMaxHealth: number;
  enemyHealth: number;
  enemyMaxHealth: number;
  lastUpdated: Date;
  battleType: BattleType;
  players: BattleParticipantDto[];
  enemies: BattleParticipantDto[];
  status: BattleStatus;
  recentActions: BattleActionDto[];
  result?: BattleResultDto;
}

// 角色DTO
interface CharacterDto {
  id: string;
  name: string;
  level: number;
  experience: number;
  health: number;
  maxHealth: number;
  mana: number;
  maxMana: number;
  attributes: AttributesDto;
  professionLevels: Record<string, number>;
  currentAction: PlayerActionState;
  equippedSkills: string[];
  equipment: Record<string, string>;
}
```

## 四、状态管理与数据流

### 4.1 状态管理架构

#### 统一事件系统
- **事件总线**: 基于观察者模式的事件分发机制
- **事件类型**: 游戏状态变更、战斗更新、库存变化等
- **订阅机制**: 组件和服务可订阅感兴趣的事件

#### 数据流向
```
用户操作 → UI组件 → 混合服务 → 本地服务/API服务 → 状态更新 → 事件分发 → UI更新
```

### 4.2 本地存储策略

#### 存储层次
1. **内存缓存**: 当前会话的临时数据
2. **LocalStorage**: 用户设置和轻量级数据
3. **IndexedDB**: 大量游戏数据的持久化存储

#### 离线数据管理
- **离线操作队列**: 记录离线时的用户操作
- **数据同步**: 重新连接时自动同步离线数据
- **冲突解决**: 提供数据冲突解决策略

## 五、错误处理与容错机制

### 5.1 网络异常处理

#### 重试策略
- **指数退避算法**: 自动重试失败的网络请求
- **熔断机制**: 防止服务器过载
- **降级策略**: 网络失败时切换到本地模式

#### 错误类型处理
- **网络超时**: 自动重试或提示用户
- **服务器错误**: 显示详细错误信息
- **数据同步失败**: 缓存操作待后续同步

### 5.2 用户体验优化

#### 加载状态管理
- **进度指示器**: 显示操作进度
- **骨架屏**: 数据加载时的占位显示
- **错误边界**: 防止组件错误传播

#### 性能优化
- **虚拟滚动**: 大列表的性能优化
- **懒加载**: 按需加载组件和数据
- **内存管理**: 及时清理不需要的数据

## 六、配置与部署

### 6.1 开发环境配置

#### 依赖包版本
```xml
<PackageReference Include="Microsoft.AspNetCore.Components.WebAssembly" Version="8.0.16" />
<PackageReference Include="Microsoft.AspNetCore.SignalR.Client" Version="9.0.9" />
```

#### 服务注册配置
```csharp
// Program.cs 中的服务配置
builder.Services.AddSingleton<ServerConfigurationService>();
builder.Services.AddSingleton<ConfigurableHttpClientFactory>();
builder.Services.AddSingleton<GameApiClient>();
// ... 其他服务注册
```

### 6.2 生产环境部署

#### 静态文件部署
- **CDN支持**: 支持静态资源CDN分发
- **压缩优化**: Gzip压缩减少传输体积
- **缓存策略**: 合适的缓存控制头设置

#### 服务器配置
- **HTTPS强制**: 生产环境强制使用HTTPS
- **CORS配置**: 正确配置跨域请求
- **WebSocket支持**: SignalR的WebSocket支持

## 总结

BlazorWebGame客户端采用现代化的前端架构设计，具备完善的功能模块、灵活的服务架构和强大的容错机制。混合服务架构确保了应用在各种网络环境下的稳定运行，为玩家提供流畅的游戏体验。

该架构的主要优势：
- ✅ 完整的离线支持
- ✅ 无缝的本地/服务器模式切换
- ✅ 模块化的服务设计
- ✅ 丰富的游戏功能
- ✅ 良好的扩展性

为进一步优化前后端分离架构，建议参考下一份文档《前后端分离优化方向分析》。